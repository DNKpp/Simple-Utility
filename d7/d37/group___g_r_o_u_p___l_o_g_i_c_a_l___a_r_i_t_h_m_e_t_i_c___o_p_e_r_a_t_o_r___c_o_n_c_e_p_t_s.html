<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simple-Utility: logical arithmetic operators</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simple-Utility
   &#160;<span id="projectnumber">v1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">logical arithmetic operators<div class="ingroups"><a class="el" href="../../d3/ddb/group___g_r_o_u_p___c_o_n_c_e_p_t_s.html">concepts</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains concepts which determines whether a type is usable in operator &amp;, &amp;=, |, |=, ^, ^= and ~ expressions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gae04a04267b95d937e8859ae7da51dc90"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gae04a04267b95d937e8859ae7da51dc90"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#gae04a04267b95d937e8859ae7da51dc90">sl::concepts::complemented</a></td></tr>
<tr class="memdesc:gae04a04267b95d937e8859ae7da51dc90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a type can be used in operator ~ expression.  <a href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#gae04a04267b95d937e8859ae7da51dc90">More...</a><br /></td></tr>
<tr class="separator:gae04a04267b95d937e8859ae7da51dc90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60de4c6599f7d03d5faf9c3f67422bf1"><td class="memTemplParams" colspan="2">template&lt;class T , class TResult  = std::remove_cvref_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga60de4c6599f7d03d5faf9c3f67422bf1"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga60de4c6599f7d03d5faf9c3f67422bf1">sl::concepts::complemented_r</a></td></tr>
<tr class="memdesc:ga60de4c6599f7d03d5faf9c3f67422bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a type can be used in operator ~ expression and if the return type is convertible to the expected one.  <a href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga60de4c6599f7d03d5faf9c3f67422bf1">More...</a><br /></td></tr>
<tr class="separator:ga60de4c6599f7d03d5faf9c3f67422bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20f4aee21ca9a971f326bf349a53fc05"><td class="memTemplParams" colspan="2">template&lt;class TLhs , class TRhs &gt; </td></tr>
<tr class="memitem:ga20f4aee21ca9a971f326bf349a53fc05"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga20f4aee21ca9a971f326bf349a53fc05">sl::concepts::conjunctive_with</a></td></tr>
<tr class="memdesc:ga20f4aee21ca9a971f326bf349a53fc05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether two types can be used in operator &amp; expressions.  <a href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga20f4aee21ca9a971f326bf349a53fc05">More...</a><br /></td></tr>
<tr class="separator:ga20f4aee21ca9a971f326bf349a53fc05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga841e99dd11b179e20964a07b26642f1b"><td class="memTemplParams" colspan="2">template&lt;class TLhs , class TRhs , class TResult  = std::remove_cvref_t&lt;TLhs&gt;&gt; </td></tr>
<tr class="memitem:ga841e99dd11b179e20964a07b26642f1b"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga841e99dd11b179e20964a07b26642f1b">sl::concepts::conjunctive_with_r</a></td></tr>
<tr class="memdesc:ga841e99dd11b179e20964a07b26642f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether two types can be used in operator &amp; expressions and if the return type is convertible to the expected one.  <a href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga841e99dd11b179e20964a07b26642f1b">More...</a><br /></td></tr>
<tr class="separator:ga841e99dd11b179e20964a07b26642f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32c689e5b618a3652da19116a6f955d3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga32c689e5b618a3652da19116a6f955d3"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga32c689e5b618a3652da19116a6f955d3">sl::concepts::conjunctive</a> = <a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga20f4aee21ca9a971f326bf349a53fc05">conjunctive_with</a>&lt;T, T&gt;</td></tr>
<tr class="memdesc:ga32c689e5b618a3652da19116a6f955d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a type can be used on both sides of operator &amp; expressions.  <a href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga32c689e5b618a3652da19116a6f955d3">More...</a><br /></td></tr>
<tr class="separator:ga32c689e5b618a3652da19116a6f955d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf05bcfd5a2ea02588de4525dbfae51b"><td class="memTemplParams" colspan="2">template&lt;class T , class TResult  = std::remove_cvref_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gaaf05bcfd5a2ea02588de4525dbfae51b"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#gaaf05bcfd5a2ea02588de4525dbfae51b">sl::concepts::conjunctive_r</a> = <a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga841e99dd11b179e20964a07b26642f1b">conjunctive_with_r</a>&lt;T, T, TResult&gt;</td></tr>
<tr class="memdesc:gaaf05bcfd5a2ea02588de4525dbfae51b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a type can be used on both sides of operator &amp; expressions and if the return type is convertible to the expected one.  <a href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#gaaf05bcfd5a2ea02588de4525dbfae51b">More...</a><br /></td></tr>
<tr class="separator:gaaf05bcfd5a2ea02588de4525dbfae51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga468bf5fbf2e6374c87d5dd111e6b8b2e"><td class="memTemplParams" colspan="2">template&lt;class TLhs , class TRhs &gt; </td></tr>
<tr class="memitem:ga468bf5fbf2e6374c87d5dd111e6b8b2e"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga468bf5fbf2e6374c87d5dd111e6b8b2e">sl::concepts::conjunctive_assign_with</a></td></tr>
<tr class="memdesc:ga468bf5fbf2e6374c87d5dd111e6b8b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether two types can be used in operator &amp;= expressions.  <a href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga468bf5fbf2e6374c87d5dd111e6b8b2e">More...</a><br /></td></tr>
<tr class="separator:ga468bf5fbf2e6374c87d5dd111e6b8b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5437d3af19794f80a033ce0afbb2d3cf"><td class="memTemplParams" colspan="2">template&lt;class TLhs , class TRhs , class TResult  = std::remove_cvref_t&lt;TLhs&gt;&amp;&gt; </td></tr>
<tr class="memitem:ga5437d3af19794f80a033ce0afbb2d3cf"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga5437d3af19794f80a033ce0afbb2d3cf">sl::concepts::conjunctive_assign_with_r</a></td></tr>
<tr class="memdesc:ga5437d3af19794f80a033ce0afbb2d3cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether two types can be used in operator &amp;= expressions and if the return type is convertible to the expected one.  <a href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga5437d3af19794f80a033ce0afbb2d3cf">More...</a><br /></td></tr>
<tr class="separator:ga5437d3af19794f80a033ce0afbb2d3cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcec81742f9506b220c1491caaacab82"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gadcec81742f9506b220c1491caaacab82"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#gadcec81742f9506b220c1491caaacab82">sl::concepts::conjunctive_assign</a> = <a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga468bf5fbf2e6374c87d5dd111e6b8b2e">conjunctive_assign_with</a>&lt;T, T&gt;</td></tr>
<tr class="memdesc:gadcec81742f9506b220c1491caaacab82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a type can be used on both sides of operator &amp;= expressions.  <a href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#gadcec81742f9506b220c1491caaacab82">More...</a><br /></td></tr>
<tr class="separator:gadcec81742f9506b220c1491caaacab82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga515fed80481d9175df16cf0109f2e670"><td class="memTemplParams" colspan="2">template&lt;class T , class TResult  = std::remove_cvref_t&lt;T&gt;&amp;&gt; </td></tr>
<tr class="memitem:ga515fed80481d9175df16cf0109f2e670"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga515fed80481d9175df16cf0109f2e670">sl::concepts::conjunctive_assign_r</a> = <a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga5437d3af19794f80a033ce0afbb2d3cf">conjunctive_assign_with_r</a>&lt;T, T, TResult&gt;</td></tr>
<tr class="memdesc:ga515fed80481d9175df16cf0109f2e670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a type can be used on both sides of operator &amp;= expressions and if the return type is convertible to the expected one.  <a href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga515fed80481d9175df16cf0109f2e670">More...</a><br /></td></tr>
<tr class="separator:ga515fed80481d9175df16cf0109f2e670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9faf8d4be789e0086a73d0323a25289"><td class="memTemplParams" colspan="2">template&lt;class TLhs , class TRhs &gt; </td></tr>
<tr class="memitem:gae9faf8d4be789e0086a73d0323a25289"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#gae9faf8d4be789e0086a73d0323a25289">sl::concepts::disjunctive_with</a></td></tr>
<tr class="memdesc:gae9faf8d4be789e0086a73d0323a25289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether two types can be used in operator | expressions.  <a href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#gae9faf8d4be789e0086a73d0323a25289">More...</a><br /></td></tr>
<tr class="separator:gae9faf8d4be789e0086a73d0323a25289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d8e6dce612fc97bd1fa071580d2e800"><td class="memTemplParams" colspan="2">template&lt;class TLhs , class TRhs , class TResult  = std::remove_cvref_t&lt;TLhs&gt;&gt; </td></tr>
<tr class="memitem:ga9d8e6dce612fc97bd1fa071580d2e800"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga9d8e6dce612fc97bd1fa071580d2e800">sl::concepts::disjunctive_with_r</a></td></tr>
<tr class="memdesc:ga9d8e6dce612fc97bd1fa071580d2e800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether two types can be used in operator | expressions and if the return type is convertible to the expected one.  <a href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga9d8e6dce612fc97bd1fa071580d2e800">More...</a><br /></td></tr>
<tr class="separator:ga9d8e6dce612fc97bd1fa071580d2e800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4c0b07b7aef000206766abb988bf8c6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gad4c0b07b7aef000206766abb988bf8c6"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#gad4c0b07b7aef000206766abb988bf8c6">sl::concepts::disjunctive</a> = <a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#gae9faf8d4be789e0086a73d0323a25289">disjunctive_with</a>&lt;T, T&gt;</td></tr>
<tr class="memdesc:gad4c0b07b7aef000206766abb988bf8c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a type can be used on both sides of operator | expressions.  <a href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#gad4c0b07b7aef000206766abb988bf8c6">More...</a><br /></td></tr>
<tr class="separator:gad4c0b07b7aef000206766abb988bf8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf58ecac1a443f56b894233b2142f574c"><td class="memTemplParams" colspan="2">template&lt;class T , class TResult  = std::remove_cvref_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gaf58ecac1a443f56b894233b2142f574c"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#gaf58ecac1a443f56b894233b2142f574c">sl::concepts::disjunctive_r</a> = <a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga9d8e6dce612fc97bd1fa071580d2e800">disjunctive_with_r</a>&lt;T, T, TResult&gt;</td></tr>
<tr class="memdesc:gaf58ecac1a443f56b894233b2142f574c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a type can be used on both sides of operator | expressions and if the return type is convertible to the expected one.  <a href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#gaf58ecac1a443f56b894233b2142f574c">More...</a><br /></td></tr>
<tr class="separator:gaf58ecac1a443f56b894233b2142f574c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga424ed40835318c43f011dd2d72d59d28"><td class="memTemplParams" colspan="2">template&lt;class TLhs , class TRhs &gt; </td></tr>
<tr class="memitem:ga424ed40835318c43f011dd2d72d59d28"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga424ed40835318c43f011dd2d72d59d28">sl::concepts::disjunctive_assign_with</a></td></tr>
<tr class="memdesc:ga424ed40835318c43f011dd2d72d59d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether two types can be used in operator |= expressions.  <a href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga424ed40835318c43f011dd2d72d59d28">More...</a><br /></td></tr>
<tr class="separator:ga424ed40835318c43f011dd2d72d59d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6b6e56fe0485e39724bdbb48e129272"><td class="memTemplParams" colspan="2">template&lt;class TLhs , class TRhs , class TResult  = std::remove_cvref_t&lt;TLhs&gt;&amp;&gt; </td></tr>
<tr class="memitem:gae6b6e56fe0485e39724bdbb48e129272"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#gae6b6e56fe0485e39724bdbb48e129272">sl::concepts::disjunctive_assign_with_r</a></td></tr>
<tr class="memdesc:gae6b6e56fe0485e39724bdbb48e129272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether two types can be used in operator |= expressions and if the return type is convertible to the expected one.  <a href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#gae6b6e56fe0485e39724bdbb48e129272">More...</a><br /></td></tr>
<tr class="separator:gae6b6e56fe0485e39724bdbb48e129272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84e51f32fa9aa5a41b653e255bd17534"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga84e51f32fa9aa5a41b653e255bd17534"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga84e51f32fa9aa5a41b653e255bd17534">sl::concepts::disjunctive_assign</a> = <a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga424ed40835318c43f011dd2d72d59d28">disjunctive_assign_with</a>&lt;T, T&gt;</td></tr>
<tr class="memdesc:ga84e51f32fa9aa5a41b653e255bd17534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a type can be used on both sides of operator |= expressions.  <a href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga84e51f32fa9aa5a41b653e255bd17534">More...</a><br /></td></tr>
<tr class="separator:ga84e51f32fa9aa5a41b653e255bd17534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0472aac355b57e700ad639ab21a39f38"><td class="memTemplParams" colspan="2">template&lt;class T , class TResult  = std::remove_cvref_t&lt;T&gt;&amp;&gt; </td></tr>
<tr class="memitem:ga0472aac355b57e700ad639ab21a39f38"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga0472aac355b57e700ad639ab21a39f38">sl::concepts::disjunctive_assign_r</a> = <a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#gae6b6e56fe0485e39724bdbb48e129272">disjunctive_assign_with_r</a>&lt;T, T, TResult&gt;</td></tr>
<tr class="memdesc:ga0472aac355b57e700ad639ab21a39f38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a type can be used on both sides of operator |= expressions and if the return type is convertible to the expected one.  <a href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga0472aac355b57e700ad639ab21a39f38">More...</a><br /></td></tr>
<tr class="separator:ga0472aac355b57e700ad639ab21a39f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e465fbeff201fce0c4b82d780aea959"><td class="memTemplParams" colspan="2">template&lt;class TLhs , class TRhs &gt; </td></tr>
<tr class="memitem:ga0e465fbeff201fce0c4b82d780aea959"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga0e465fbeff201fce0c4b82d780aea959">sl::concepts::exclusive_disjunctive_with</a></td></tr>
<tr class="memdesc:ga0e465fbeff201fce0c4b82d780aea959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether two types can be used in operator ^ expressions.  <a href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga0e465fbeff201fce0c4b82d780aea959">More...</a><br /></td></tr>
<tr class="separator:ga0e465fbeff201fce0c4b82d780aea959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42b77363ee7c78cf2cb05b429b4566bd"><td class="memTemplParams" colspan="2">template&lt;class TLhs , class TRhs , class TResult  = std::remove_cvref_t&lt;TLhs&gt;&gt; </td></tr>
<tr class="memitem:ga42b77363ee7c78cf2cb05b429b4566bd"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga42b77363ee7c78cf2cb05b429b4566bd">sl::concepts::exclusive_disjunctive_with_r</a></td></tr>
<tr class="memdesc:ga42b77363ee7c78cf2cb05b429b4566bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether two types can be used in operator ^ expressions and if the return type is convertible to the expected one.  <a href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga42b77363ee7c78cf2cb05b429b4566bd">More...</a><br /></td></tr>
<tr class="separator:ga42b77363ee7c78cf2cb05b429b4566bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga590a972cac46584600d63aff98d71e6c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga590a972cac46584600d63aff98d71e6c"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga590a972cac46584600d63aff98d71e6c">sl::concepts::exclusive_disjunctive</a> = <a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga0e465fbeff201fce0c4b82d780aea959">exclusive_disjunctive_with</a>&lt;T, T&gt;</td></tr>
<tr class="memdesc:ga590a972cac46584600d63aff98d71e6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a type can be used on both sides of operator ^ expressions.  <a href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga590a972cac46584600d63aff98d71e6c">More...</a><br /></td></tr>
<tr class="separator:ga590a972cac46584600d63aff98d71e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60c1a8595735659ab6f849d57dd9dbc3"><td class="memTemplParams" colspan="2">template&lt;class T , class TResult  = std::remove_cvref_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga60c1a8595735659ab6f849d57dd9dbc3"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga60c1a8595735659ab6f849d57dd9dbc3">sl::concepts::exclusive_disjunctive_r</a> = <a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga42b77363ee7c78cf2cb05b429b4566bd">exclusive_disjunctive_with_r</a>&lt;T, T, TResult&gt;</td></tr>
<tr class="memdesc:ga60c1a8595735659ab6f849d57dd9dbc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a type can be used on both sides of operator ^ expressions and if the return type is convertible to the expected one.  <a href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga60c1a8595735659ab6f849d57dd9dbc3">More...</a><br /></td></tr>
<tr class="separator:ga60c1a8595735659ab6f849d57dd9dbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb7e84a85c79fc2227cfd590a366cdb4"><td class="memTemplParams" colspan="2">template&lt;class TLhs , class TRhs &gt; </td></tr>
<tr class="memitem:gafb7e84a85c79fc2227cfd590a366cdb4"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#gafb7e84a85c79fc2227cfd590a366cdb4">sl::concepts::exclusive_disjunctive_assign_with</a></td></tr>
<tr class="memdesc:gafb7e84a85c79fc2227cfd590a366cdb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether two types can be used in operator ^= expressions.  <a href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#gafb7e84a85c79fc2227cfd590a366cdb4">More...</a><br /></td></tr>
<tr class="separator:gafb7e84a85c79fc2227cfd590a366cdb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6658e925cc874932abfd1d74f34b8b7b"><td class="memTemplParams" colspan="2">template&lt;class TLhs , class TRhs , class TResult  = std::remove_cvref_t&lt;TLhs&gt;&amp;&gt; </td></tr>
<tr class="memitem:ga6658e925cc874932abfd1d74f34b8b7b"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga6658e925cc874932abfd1d74f34b8b7b">sl::concepts::exclusive_disjunctive_assign_with_r</a></td></tr>
<tr class="memdesc:ga6658e925cc874932abfd1d74f34b8b7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether two types can be used in operator ^= expressions and if the return type is convertible to the expected one.  <a href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga6658e925cc874932abfd1d74f34b8b7b">More...</a><br /></td></tr>
<tr class="separator:ga6658e925cc874932abfd1d74f34b8b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f3feb87551043dbef50f0e018844e9f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga9f3feb87551043dbef50f0e018844e9f"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga9f3feb87551043dbef50f0e018844e9f">sl::concepts::exclusive_disjunctive_assign</a> = <a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#gafb7e84a85c79fc2227cfd590a366cdb4">exclusive_disjunctive_assign_with</a>&lt;T, T&gt;</td></tr>
<tr class="memdesc:ga9f3feb87551043dbef50f0e018844e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a type can be used on both sides of operator ^= expressions.  <a href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga9f3feb87551043dbef50f0e018844e9f">More...</a><br /></td></tr>
<tr class="separator:ga9f3feb87551043dbef50f0e018844e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1a3b34c093633fa1fce1ac8c1511fe8"><td class="memTemplParams" colspan="2">template&lt;class T , class TResult  = std::remove_cvref_t&lt;T&gt;&amp;&gt; </td></tr>
<tr class="memitem:gae1a3b34c093633fa1fce1ac8c1511fe8"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#gae1a3b34c093633fa1fce1ac8c1511fe8">sl::concepts::exclusive_disjunctive_assign_r</a> = <a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga6658e925cc874932abfd1d74f34b8b7b">exclusive_disjunctive_assign_with_r</a>&lt;T, T, TResult&gt;</td></tr>
<tr class="memdesc:gae1a3b34c093633fa1fce1ac8c1511fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a type can be used on both sides of operator ^= expressions and if the return type is convertible to the expected one.  <a href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#gae1a3b34c093633fa1fce1ac8c1511fe8">More...</a><br /></td></tr>
<tr class="separator:gae1a3b34c093633fa1fce1ac8c1511fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebcb92033ac39792270f5d34b7bcbd80"><td class="memTemplParams" colspan="2">template&lt;class TLhs , class TRhs &gt; </td></tr>
<tr class="memitem:gaebcb92033ac39792270f5d34b7bcbd80"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#gaebcb92033ac39792270f5d34b7bcbd80">sl::concepts::logically_combinable_with</a></td></tr>
<tr class="memdesc:gaebcb92033ac39792270f5d34b7bcbd80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether two types can be used in operator &amp;, | amd ^ expressions.  <a href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#gaebcb92033ac39792270f5d34b7bcbd80">More...</a><br /></td></tr>
<tr class="separator:gaebcb92033ac39792270f5d34b7bcbd80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga842ed63a2882193b04c7c295603b9a97"><td class="memTemplParams" colspan="2">template&lt;class TLhs , class TRhs , class TResult  = std::remove_cvref_t&lt;TLhs&gt;&gt; </td></tr>
<tr class="memitem:ga842ed63a2882193b04c7c295603b9a97"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga842ed63a2882193b04c7c295603b9a97">sl::concepts::logically_combinable_with_r</a></td></tr>
<tr class="memdesc:ga842ed63a2882193b04c7c295603b9a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether two types can be used in operator &amp;, | amd ^ expressions and if the return type is convertible to the expected one.  <a href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga842ed63a2882193b04c7c295603b9a97">More...</a><br /></td></tr>
<tr class="separator:ga842ed63a2882193b04c7c295603b9a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga013af46b375948256f1dcdcd3ca46e41"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga013af46b375948256f1dcdcd3ca46e41"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga013af46b375948256f1dcdcd3ca46e41">sl::concepts::logically_combinable</a></td></tr>
<tr class="memdesc:ga013af46b375948256f1dcdcd3ca46e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a type can be used on both sides of operator &amp;, | and ^ expressions.  <a href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga013af46b375948256f1dcdcd3ca46e41">More...</a><br /></td></tr>
<tr class="separator:ga013af46b375948256f1dcdcd3ca46e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa54e1b7b4517b78ec8a8df32ec501708"><td class="memTemplParams" colspan="2">template&lt;class T , class TResult  = std::remove_cvref_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gaa54e1b7b4517b78ec8a8df32ec501708"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#gaa54e1b7b4517b78ec8a8df32ec501708">sl::concepts::logically_combinable_r</a></td></tr>
<tr class="memdesc:gaa54e1b7b4517b78ec8a8df32ec501708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a type can be used on both sides of operator &amp;, | and ^ expressions and if the return type is convertible to the expected one.  <a href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#gaa54e1b7b4517b78ec8a8df32ec501708">More...</a><br /></td></tr>
<tr class="separator:gaa54e1b7b4517b78ec8a8df32ec501708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacf5aaf6f67a161d30ed7c8223b366ce"><td class="memTemplParams" colspan="2">template&lt;class TLhs , class TRhs &gt; </td></tr>
<tr class="memitem:gaacf5aaf6f67a161d30ed7c8223b366ce"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#gaacf5aaf6f67a161d30ed7c8223b366ce">sl::concepts::logically_assignable_with</a></td></tr>
<tr class="memdesc:gaacf5aaf6f67a161d30ed7c8223b366ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether two types can be used in operator &amp;=, |= and ^= expressions.  <a href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#gaacf5aaf6f67a161d30ed7c8223b366ce">More...</a><br /></td></tr>
<tr class="separator:gaacf5aaf6f67a161d30ed7c8223b366ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcef1a5427564b35e1dcdf2757a80e73"><td class="memTemplParams" colspan="2">template&lt;class TLhs , class TRhs , class TResult  = std::remove_cvref_t&lt;TLhs&gt;&amp;&gt; </td></tr>
<tr class="memitem:gabcef1a5427564b35e1dcdf2757a80e73"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#gabcef1a5427564b35e1dcdf2757a80e73">sl::concepts::logically_assignable_with_r</a></td></tr>
<tr class="memdesc:gabcef1a5427564b35e1dcdf2757a80e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether two types can be used in operator &amp;=, |= and ^= expressions and if the return type is convertible to the expected one.  <a href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#gabcef1a5427564b35e1dcdf2757a80e73">More...</a><br /></td></tr>
<tr class="separator:gabcef1a5427564b35e1dcdf2757a80e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdccd030d7510453de0453936a45f078"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gabdccd030d7510453de0453936a45f078"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#gabdccd030d7510453de0453936a45f078">sl::concepts::logically_assignable</a></td></tr>
<tr class="memdesc:gabdccd030d7510453de0453936a45f078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a type can be used on both sides of operator &amp;=, |= and ^= expressions.  <a href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#gabdccd030d7510453de0453936a45f078">More...</a><br /></td></tr>
<tr class="separator:gabdccd030d7510453de0453936a45f078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf907a6e493820905cea8c3439c00477c"><td class="memTemplParams" colspan="2">template&lt;class T , class TResult  = std::remove_cvref_t&lt;T&gt;&amp;&gt; </td></tr>
<tr class="memitem:gaf907a6e493820905cea8c3439c00477c"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#gaf907a6e493820905cea8c3439c00477c">sl::concepts::logically_assignable_r</a></td></tr>
<tr class="memdesc:gaf907a6e493820905cea8c3439c00477c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a type can be used on both sides of operator &amp;=, |= and ^= expressions and if the return type is convertible to the expected one.  <a href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#gaf907a6e493820905cea8c3439c00477c">More...</a><br /></td></tr>
<tr class="separator:gaf907a6e493820905cea8c3439c00477c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f9e47138ce99bfe4a382949beed6ee0"><td class="memTemplParams" colspan="2">template&lt;class TLhs , class TRhs &gt; </td></tr>
<tr class="memitem:ga6f9e47138ce99bfe4a382949beed6ee0"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga6f9e47138ce99bfe4a382949beed6ee0">sl::concepts::fully_logical_with</a></td></tr>
<tr class="memdesc:ga6f9e47138ce99bfe4a382949beed6ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether two types can be used in operator &amp;, |, ^, &amp;=, |=, ^= and ~ expressions.  <a href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga6f9e47138ce99bfe4a382949beed6ee0">More...</a><br /></td></tr>
<tr class="separator:ga6f9e47138ce99bfe4a382949beed6ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga419df4c9ea09e2e3211e88a1c37dcd29"><td class="memTemplParams" colspan="2">template&lt;class TLhs , class TRhs , class TCombineResult  = std::remove_cvref_t&lt;TLhs&gt;, class TAssignResult  = std::remove_cvref_t&lt;TLhs&gt;&amp;&gt; </td></tr>
<tr class="memitem:ga419df4c9ea09e2e3211e88a1c37dcd29"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga419df4c9ea09e2e3211e88a1c37dcd29">sl::concepts::fully_logical_with_r</a></td></tr>
<tr class="memdesc:ga419df4c9ea09e2e3211e88a1c37dcd29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether two types can be used in operator &amp;, |, ^, &amp;=, |=, ^= and ~ expressions and if the return types are convertible to the expected ones.  <a href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga419df4c9ea09e2e3211e88a1c37dcd29">More...</a><br /></td></tr>
<tr class="separator:ga419df4c9ea09e2e3211e88a1c37dcd29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05595c0b5c0cc38b430e75973ab8f67c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga05595c0b5c0cc38b430e75973ab8f67c"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga05595c0b5c0cc38b430e75973ab8f67c">sl::concepts::fully_logical</a></td></tr>
<tr class="memdesc:ga05595c0b5c0cc38b430e75973ab8f67c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a type can be used on both sides of operator &amp;, |, ^, &amp;=, |=, ^= and ~ expressions.  <a href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga05595c0b5c0cc38b430e75973ab8f67c">More...</a><br /></td></tr>
<tr class="separator:ga05595c0b5c0cc38b430e75973ab8f67c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22bb3ac35dfa5bc43309984809c71384"><td class="memTemplParams" colspan="2">template&lt;class T , class TCombineResult  = std::remove_cvref_t&lt;T&gt;, class TAssignResult  = std::remove_cvref_t&lt;T&gt;&amp;&gt; </td></tr>
<tr class="memitem:ga22bb3ac35dfa5bc43309984809c71384"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga22bb3ac35dfa5bc43309984809c71384">sl::concepts::fully_logical_r</a></td></tr>
<tr class="memdesc:ga22bb3ac35dfa5bc43309984809c71384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a type can be used on both sides of operator &amp;, |, ^, &amp;=, |=, ^= and ~ expressions and if the return types are convertible to the expected ones.  <a href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga22bb3ac35dfa5bc43309984809c71384">More...</a><br /></td></tr>
<tr class="separator:ga22bb3ac35dfa5bc43309984809c71384"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Contains concepts which determines whether a type is usable in operator &amp;, &amp;=, |, |=, ^, ^= and ~ expressions. </p>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gae04a04267b95d937e8859ae7da51dc90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae04a04267b95d937e8859ae7da51dc90">&#9670;&nbsp;</a></span>complemented</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept sl::concepts::complemented</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= requires(T t)</div>
<div class="line">    {</div>
<div class="line">        { ~t };</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Determines whether a type can be used in operator ~ expression. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga60de4c6599f7d03d5faf9c3f67422bf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60de4c6599f7d03d5faf9c3f67422bf1">&#9670;&nbsp;</a></span>complemented_r</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class TResult  = std::remove_cvref_t&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept sl::concepts::complemented_r</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= requires(T t)</div>
<div class="line">    {</div>
<div class="line">        { ~t } -&gt; std::convertible_to&lt;TResult&gt;;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Determines whether a type can be used in operator ~ expression and if the return type is convertible to the expected one. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to check </td></tr>
    <tr><td class="paramname">TResult</td><td>The expected return type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga32c689e5b618a3652da19116a6f955d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32c689e5b618a3652da19116a6f955d3">&#9670;&nbsp;</a></span>conjunctive</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept sl::concepts::conjunctive = <a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga20f4aee21ca9a971f326bf349a53fc05">conjunctive_with</a>&lt;T, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a type can be used on both sides of operator &amp; expressions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadcec81742f9506b220c1491caaacab82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcec81742f9506b220c1491caaacab82">&#9670;&nbsp;</a></span>conjunctive_assign</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept sl::concepts::conjunctive_assign = <a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga468bf5fbf2e6374c87d5dd111e6b8b2e">conjunctive_assign_with</a>&lt;T, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a type can be used on both sides of operator &amp;= expressions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga515fed80481d9175df16cf0109f2e670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga515fed80481d9175df16cf0109f2e670">&#9670;&nbsp;</a></span>conjunctive_assign_r</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class TResult  = std::remove_cvref_t&lt;T&gt;&amp;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept sl::concepts::conjunctive_assign_r = <a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga5437d3af19794f80a033ce0afbb2d3cf">conjunctive_assign_with_r</a>&lt;T, T, TResult&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a type can be used on both sides of operator &amp;= expressions and if the return type is convertible to the expected one. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to check </td></tr>
    <tr><td class="paramname">TResult</td><td>The expected return type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga468bf5fbf2e6374c87d5dd111e6b8b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga468bf5fbf2e6374c87d5dd111e6b8b2e">&#9670;&nbsp;</a></span>conjunctive_assign_with</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLhs , class TRhs &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept sl::concepts::conjunctive_assign_with</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= requires(TLhs lhs, TRhs rhs)</div>
<div class="line">    {</div>
<div class="line">        { lhs &amp;= rhs };</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Determines whether two types can be used in operator &amp;= expressions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TLhs</td><td>The left-hand-side type </td></tr>
    <tr><td class="paramname">TRhs</td><td>the right-hand-side-type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5437d3af19794f80a033ce0afbb2d3cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5437d3af19794f80a033ce0afbb2d3cf">&#9670;&nbsp;</a></span>conjunctive_assign_with_r</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLhs , class TRhs , class TResult  = std::remove_cvref_t&lt;TLhs&gt;&amp;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept sl::concepts::conjunctive_assign_with_r</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= requires(TLhs lhs, TRhs rhs)</div>
<div class="line">    {</div>
<div class="line">        { lhs &amp;= rhs } -&gt; std::convertible_to&lt;TResult&gt;;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Determines whether two types can be used in operator &amp;= expressions and if the return type is convertible to the expected one. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TLhs</td><td>The left-hand-side type </td></tr>
    <tr><td class="paramname">TRhs</td><td>the right-hand-side-type </td></tr>
    <tr><td class="paramname">TResult</td><td>The expected return type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaf05bcfd5a2ea02588de4525dbfae51b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf05bcfd5a2ea02588de4525dbfae51b">&#9670;&nbsp;</a></span>conjunctive_r</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class TResult  = std::remove_cvref_t&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept sl::concepts::conjunctive_r = <a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga841e99dd11b179e20964a07b26642f1b">conjunctive_with_r</a>&lt;T, T, TResult&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a type can be used on both sides of operator &amp; expressions and if the return type is convertible to the expected one. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to check </td></tr>
    <tr><td class="paramname">TResult</td><td>The expected return type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga20f4aee21ca9a971f326bf349a53fc05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20f4aee21ca9a971f326bf349a53fc05">&#9670;&nbsp;</a></span>conjunctive_with</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLhs , class TRhs &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept sl::concepts::conjunctive_with</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= requires(TLhs lhs, TRhs rhs)</div>
<div class="line">    {</div>
<div class="line">        { lhs &amp; rhs };</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Determines whether two types can be used in operator &amp; expressions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TLhs</td><td>The left-hand-side type </td></tr>
    <tr><td class="paramname">TRhs</td><td>the right-hand-side-type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga841e99dd11b179e20964a07b26642f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga841e99dd11b179e20964a07b26642f1b">&#9670;&nbsp;</a></span>conjunctive_with_r</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLhs , class TRhs , class TResult  = std::remove_cvref_t&lt;TLhs&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept sl::concepts::conjunctive_with_r</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= requires(TLhs lhs, TRhs rhs)</div>
<div class="line">    {</div>
<div class="line">        { lhs &amp; rhs } -&gt; std::convertible_to&lt;TResult&gt;;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Determines whether two types can be used in operator &amp; expressions and if the return type is convertible to the expected one. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TLhs</td><td>The left-hand-side type </td></tr>
    <tr><td class="paramname">TRhs</td><td>the right-hand-side-type </td></tr>
    <tr><td class="paramname">TResult</td><td>The expected return type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad4c0b07b7aef000206766abb988bf8c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4c0b07b7aef000206766abb988bf8c6">&#9670;&nbsp;</a></span>disjunctive</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept sl::concepts::disjunctive = <a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#gae9faf8d4be789e0086a73d0323a25289">disjunctive_with</a>&lt;T, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a type can be used on both sides of operator | expressions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga84e51f32fa9aa5a41b653e255bd17534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84e51f32fa9aa5a41b653e255bd17534">&#9670;&nbsp;</a></span>disjunctive_assign</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept sl::concepts::disjunctive_assign = <a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga424ed40835318c43f011dd2d72d59d28">disjunctive_assign_with</a>&lt;T, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a type can be used on both sides of operator |= expressions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0472aac355b57e700ad639ab21a39f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0472aac355b57e700ad639ab21a39f38">&#9670;&nbsp;</a></span>disjunctive_assign_r</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class TResult  = std::remove_cvref_t&lt;T&gt;&amp;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept sl::concepts::disjunctive_assign_r = <a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#gae6b6e56fe0485e39724bdbb48e129272">disjunctive_assign_with_r</a>&lt;T, T, TResult&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a type can be used on both sides of operator |= expressions and if the return type is convertible to the expected one. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to check </td></tr>
    <tr><td class="paramname">TResult</td><td>The expected return type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga424ed40835318c43f011dd2d72d59d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga424ed40835318c43f011dd2d72d59d28">&#9670;&nbsp;</a></span>disjunctive_assign_with</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLhs , class TRhs &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept sl::concepts::disjunctive_assign_with</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= requires(TLhs lhs, TRhs rhs)</div>
<div class="line">    {</div>
<div class="line">        { lhs |= rhs };</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Determines whether two types can be used in operator |= expressions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TLhs</td><td>The left-hand-side type </td></tr>
    <tr><td class="paramname">TRhs</td><td>the right-hand-side-type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae6b6e56fe0485e39724bdbb48e129272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6b6e56fe0485e39724bdbb48e129272">&#9670;&nbsp;</a></span>disjunctive_assign_with_r</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLhs , class TRhs , class TResult  = std::remove_cvref_t&lt;TLhs&gt;&amp;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept sl::concepts::disjunctive_assign_with_r</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= requires(TLhs lhs, TRhs rhs)</div>
<div class="line">    {</div>
<div class="line">        { lhs |= rhs } -&gt; std::convertible_to&lt;TResult&gt;;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Determines whether two types can be used in operator |= expressions and if the return type is convertible to the expected one. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TLhs</td><td>The left-hand-side type </td></tr>
    <tr><td class="paramname">TRhs</td><td>the right-hand-side-type </td></tr>
    <tr><td class="paramname">TResult</td><td>The expected return type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf58ecac1a443f56b894233b2142f574c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf58ecac1a443f56b894233b2142f574c">&#9670;&nbsp;</a></span>disjunctive_r</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class TResult  = std::remove_cvref_t&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept sl::concepts::disjunctive_r = <a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga9d8e6dce612fc97bd1fa071580d2e800">disjunctive_with_r</a>&lt;T, T, TResult&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a type can be used on both sides of operator | expressions and if the return type is convertible to the expected one. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to check </td></tr>
    <tr><td class="paramname">TResult</td><td>The expected return type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae9faf8d4be789e0086a73d0323a25289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9faf8d4be789e0086a73d0323a25289">&#9670;&nbsp;</a></span>disjunctive_with</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLhs , class TRhs &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept sl::concepts::disjunctive_with</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= requires(TLhs lhs, TRhs rhs)</div>
<div class="line">    {</div>
<div class="line">        { lhs | rhs };</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Determines whether two types can be used in operator | expressions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TLhs</td><td>The left-hand-side type </td></tr>
    <tr><td class="paramname">TRhs</td><td>the right-hand-side-type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9d8e6dce612fc97bd1fa071580d2e800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d8e6dce612fc97bd1fa071580d2e800">&#9670;&nbsp;</a></span>disjunctive_with_r</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLhs , class TRhs , class TResult  = std::remove_cvref_t&lt;TLhs&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept sl::concepts::disjunctive_with_r</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= requires(TLhs lhs, TRhs rhs)</div>
<div class="line">    {</div>
<div class="line">        { lhs | rhs } -&gt; std::convertible_to&lt;TResult&gt;;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Determines whether two types can be used in operator | expressions and if the return type is convertible to the expected one. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TLhs</td><td>The left-hand-side type </td></tr>
    <tr><td class="paramname">TRhs</td><td>the right-hand-side-type </td></tr>
    <tr><td class="paramname">TResult</td><td>The expected return type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga590a972cac46584600d63aff98d71e6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga590a972cac46584600d63aff98d71e6c">&#9670;&nbsp;</a></span>exclusive_disjunctive</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept sl::concepts::exclusive_disjunctive = <a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga0e465fbeff201fce0c4b82d780aea959">exclusive_disjunctive_with</a>&lt;T, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a type can be used on both sides of operator ^ expressions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9f3feb87551043dbef50f0e018844e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f3feb87551043dbef50f0e018844e9f">&#9670;&nbsp;</a></span>exclusive_disjunctive_assign</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept sl::concepts::exclusive_disjunctive_assign = <a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#gafb7e84a85c79fc2227cfd590a366cdb4">exclusive_disjunctive_assign_with</a>&lt;T, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a type can be used on both sides of operator ^= expressions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae1a3b34c093633fa1fce1ac8c1511fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1a3b34c093633fa1fce1ac8c1511fe8">&#9670;&nbsp;</a></span>exclusive_disjunctive_assign_r</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class TResult  = std::remove_cvref_t&lt;T&gt;&amp;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept sl::concepts::exclusive_disjunctive_assign_r = <a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga6658e925cc874932abfd1d74f34b8b7b">exclusive_disjunctive_assign_with_r</a>&lt;T, T, TResult&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a type can be used on both sides of operator ^= expressions and if the return type is convertible to the expected one. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to check </td></tr>
    <tr><td class="paramname">TResult</td><td>The expected return type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafb7e84a85c79fc2227cfd590a366cdb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb7e84a85c79fc2227cfd590a366cdb4">&#9670;&nbsp;</a></span>exclusive_disjunctive_assign_with</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLhs , class TRhs &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept sl::concepts::exclusive_disjunctive_assign_with</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= requires(TLhs lhs, TRhs rhs)</div>
<div class="line">    {</div>
<div class="line">        { lhs ^= rhs };</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Determines whether two types can be used in operator ^= expressions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TLhs</td><td>The left-hand-side type </td></tr>
    <tr><td class="paramname">TRhs</td><td>the right-hand-side-type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6658e925cc874932abfd1d74f34b8b7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6658e925cc874932abfd1d74f34b8b7b">&#9670;&nbsp;</a></span>exclusive_disjunctive_assign_with_r</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLhs , class TRhs , class TResult  = std::remove_cvref_t&lt;TLhs&gt;&amp;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept sl::concepts::exclusive_disjunctive_assign_with_r</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= requires(TLhs lhs, TRhs rhs)</div>
<div class="line">    {</div>
<div class="line">        { lhs ^= rhs } -&gt; std::convertible_to&lt;TResult&gt;;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Determines whether two types can be used in operator ^= expressions and if the return type is convertible to the expected one. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TLhs</td><td>The left-hand-side type </td></tr>
    <tr><td class="paramname">TRhs</td><td>the right-hand-side-type </td></tr>
    <tr><td class="paramname">TResult</td><td>The expected return type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga60c1a8595735659ab6f849d57dd9dbc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60c1a8595735659ab6f849d57dd9dbc3">&#9670;&nbsp;</a></span>exclusive_disjunctive_r</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class TResult  = std::remove_cvref_t&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept sl::concepts::exclusive_disjunctive_r = <a class="el" href="../../d7/d37/group___g_r_o_u_p___l_o_g_i_c_a_l___a_r_i_t_h_m_e_t_i_c___o_p_e_r_a_t_o_r___c_o_n_c_e_p_t_s.html#ga42b77363ee7c78cf2cb05b429b4566bd">exclusive_disjunctive_with_r</a>&lt;T, T, TResult&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a type can be used on both sides of operator ^ expressions and if the return type is convertible to the expected one. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to check </td></tr>
    <tr><td class="paramname">TResult</td><td>The expected return type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0e465fbeff201fce0c4b82d780aea959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e465fbeff201fce0c4b82d780aea959">&#9670;&nbsp;</a></span>exclusive_disjunctive_with</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLhs , class TRhs &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept sl::concepts::exclusive_disjunctive_with</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= requires(TLhs lhs, TRhs rhs)</div>
<div class="line">    {</div>
<div class="line">        { lhs ^ rhs };</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Determines whether two types can be used in operator ^ expressions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TLhs</td><td>The left-hand-side type </td></tr>
    <tr><td class="paramname">TRhs</td><td>the right-hand-side-type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga42b77363ee7c78cf2cb05b429b4566bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42b77363ee7c78cf2cb05b429b4566bd">&#9670;&nbsp;</a></span>exclusive_disjunctive_with_r</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLhs , class TRhs , class TResult  = std::remove_cvref_t&lt;TLhs&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept sl::concepts::exclusive_disjunctive_with_r</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= requires(TLhs lhs, TRhs rhs)</div>
<div class="line">    {</div>
<div class="line">        { lhs ^ rhs } -&gt; std::convertible_to&lt;TResult&gt;;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Determines whether two types can be used in operator ^ expressions and if the return type is convertible to the expected one. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TLhs</td><td>The left-hand-side type </td></tr>
    <tr><td class="paramname">TRhs</td><td>the right-hand-side-type </td></tr>
    <tr><td class="paramname">TResult</td><td>The expected return type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga05595c0b5c0cc38b430e75973ab8f67c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05595c0b5c0cc38b430e75973ab8f67c">&#9670;&nbsp;</a></span>fully_logical</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept sl::concepts::fully_logical</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= complemented&lt;T&gt;</div>
<div class="line">                            &amp;&amp; logically_combinable&lt;T&gt;</div>
<div class="line">                            &amp;&amp; logically_assignable&lt;T&gt;</div>
</div><!-- fragment -->
<p>Determines whether a type can be used on both sides of operator &amp;, |, ^, &amp;=, |=, ^= and ~ expressions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga22bb3ac35dfa5bc43309984809c71384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22bb3ac35dfa5bc43309984809c71384">&#9670;&nbsp;</a></span>fully_logical_r</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class TCombineResult  = std::remove_cvref_t&lt;T&gt;, class TAssignResult  = std::remove_cvref_t&lt;T&gt;&amp;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept sl::concepts::fully_logical_r</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= complemented_r&lt;T, TCombineResult&gt;</div>
<div class="line">                            &amp;&amp; logically_combinable_r&lt;T, TCombineResult&gt;</div>
<div class="line">                            &amp;&amp; logically_assignable_r&lt;T, TAssignResult&gt;</div>
</div><!-- fragment -->
<p>Determines whether a type can be used on both sides of operator &amp;, |, ^, &amp;=, |=, ^= and ~ expressions and if the return types are convertible to the expected ones. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to check </td></tr>
    <tr><td class="paramname">TCombineResult</td><td>The expected return type of combining operations </td></tr>
    <tr><td class="paramname">TAssignResult</td><td>The expected return type of assigning operations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6f9e47138ce99bfe4a382949beed6ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f9e47138ce99bfe4a382949beed6ee0">&#9670;&nbsp;</a></span>fully_logical_with</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLhs , class TRhs &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept sl::concepts::fully_logical_with</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= complemented&lt;TLhs&gt;</div>
<div class="line">                                &amp;&amp; logically_combinable_with&lt;TLhs, TRhs&gt;</div>
<div class="line">                                &amp;&amp; logically_assignable_with&lt;TLhs, TRhs&gt;</div>
</div><!-- fragment -->
<p>Determines whether two types can be used in operator &amp;, |, ^, &amp;=, |=, ^= and ~ expressions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TLhs</td><td>The left-hand-side type </td></tr>
    <tr><td class="paramname">TRhs</td><td>the right-hand-side-type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga419df4c9ea09e2e3211e88a1c37dcd29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga419df4c9ea09e2e3211e88a1c37dcd29">&#9670;&nbsp;</a></span>fully_logical_with_r</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLhs , class TRhs , class TCombineResult  = std::remove_cvref_t&lt;TLhs&gt;, class TAssignResult  = std::remove_cvref_t&lt;TLhs&gt;&amp;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept sl::concepts::fully_logical_with_r</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= complemented_r&lt;TLhs, TCombineResult&gt;</div>
<div class="line">                                    &amp;&amp; logically_combinable_with_r&lt;TLhs, TRhs, TCombineResult&gt;</div>
<div class="line">                                    &amp;&amp; logically_assignable_with_r&lt;TLhs, TRhs, TAssignResult&gt;</div>
</div><!-- fragment -->
<p>Determines whether two types can be used in operator &amp;, |, ^, &amp;=, |=, ^= and ~ expressions and if the return types are convertible to the expected ones. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TLhs</td><td>The left-hand-side type </td></tr>
    <tr><td class="paramname">TRhs</td><td>the right-hand-side-type </td></tr>
    <tr><td class="paramname">TCombineResult</td><td>The expected return type of combining operations </td></tr>
    <tr><td class="paramname">TAssignResult</td><td>The expected return type of assigning operations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabdccd030d7510453de0453936a45f078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdccd030d7510453de0453936a45f078">&#9670;&nbsp;</a></span>logically_assignable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept sl::concepts::logically_assignable</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= conjunctive_assign&lt;T&gt;</div>
<div class="line">                                    &amp;&amp; disjunctive_assign&lt;T&gt;</div>
<div class="line">                                    &amp;&amp; exclusive_disjunctive_assign&lt;T&gt;</div>
</div><!-- fragment -->
<p>Determines whether a type can be used on both sides of operator &amp;=, |= and ^= expressions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf907a6e493820905cea8c3439c00477c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf907a6e493820905cea8c3439c00477c">&#9670;&nbsp;</a></span>logically_assignable_r</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class TResult  = std::remove_cvref_t&lt;T&gt;&amp;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept sl::concepts::logically_assignable_r</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= conjunctive_assign_r&lt;T, TResult&gt;</div>
<div class="line">                                    &amp;&amp; disjunctive_assign_r&lt;T, TResult&gt;</div>
<div class="line">                                    &amp;&amp; exclusive_disjunctive_assign_r&lt;T, TResult&gt;</div>
</div><!-- fragment -->
<p>Determines whether a type can be used on both sides of operator &amp;=, |= and ^= expressions and if the return type is convertible to the expected one. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to check </td></tr>
    <tr><td class="paramname">TResult</td><td>The expected return type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaacf5aaf6f67a161d30ed7c8223b366ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacf5aaf6f67a161d30ed7c8223b366ce">&#9670;&nbsp;</a></span>logically_assignable_with</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLhs , class TRhs &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept sl::concepts::logically_assignable_with</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= conjunctive_assign_with&lt;TLhs, TRhs&gt;</div>
<div class="line">                                        &amp;&amp; disjunctive_assign_with&lt;TLhs, TRhs&gt;</div>
<div class="line">                                        &amp;&amp; exclusive_disjunctive_assign_with&lt;TLhs, TRhs&gt;</div>
</div><!-- fragment -->
<p>Determines whether two types can be used in operator &amp;=, |= and ^= expressions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TLhs</td><td>The left-hand-side type </td></tr>
    <tr><td class="paramname">TRhs</td><td>the right-hand-side-type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabcef1a5427564b35e1dcdf2757a80e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcef1a5427564b35e1dcdf2757a80e73">&#9670;&nbsp;</a></span>logically_assignable_with_r</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLhs , class TRhs , class TResult  = std::remove_cvref_t&lt;TLhs&gt;&amp;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept sl::concepts::logically_assignable_with_r</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= conjunctive_assign_with_r&lt;TLhs, TRhs, TResult&gt;</div>
<div class="line">                                        &amp;&amp; disjunctive_assign_with_r&lt;TLhs, TRhs, TResult&gt;</div>
<div class="line">                                        &amp;&amp; exclusive_disjunctive_assign_with_r&lt;TLhs, TRhs, TResult&gt;</div>
</div><!-- fragment -->
<p>Determines whether two types can be used in operator &amp;=, |= and ^= expressions and if the return type is convertible to the expected one. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TLhs</td><td>The left-hand-side type </td></tr>
    <tr><td class="paramname">TRhs</td><td>the right-hand-side-type </td></tr>
    <tr><td class="paramname">TResult</td><td>The expected return type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga013af46b375948256f1dcdcd3ca46e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga013af46b375948256f1dcdcd3ca46e41">&#9670;&nbsp;</a></span>logically_combinable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept sl::concepts::logically_combinable</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= conjunctive&lt;T&gt;</div>
<div class="line">                                    &amp;&amp; disjunctive&lt;T&gt;</div>
<div class="line">                                    &amp;&amp; exclusive_disjunctive&lt;T&gt;</div>
</div><!-- fragment -->
<p>Determines whether a type can be used on both sides of operator &amp;, | and ^ expressions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa54e1b7b4517b78ec8a8df32ec501708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa54e1b7b4517b78ec8a8df32ec501708">&#9670;&nbsp;</a></span>logically_combinable_r</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class TResult  = std::remove_cvref_t&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept sl::concepts::logically_combinable_r</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= conjunctive_r&lt;T, TResult&gt;</div>
<div class="line">                                    &amp;&amp; disjunctive_r&lt;T, TResult&gt;</div>
<div class="line">                                    &amp;&amp; exclusive_disjunctive_r&lt;T, TResult&gt;</div>
</div><!-- fragment -->
<p>Determines whether a type can be used on both sides of operator &amp;, | and ^ expressions and if the return type is convertible to the expected one. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to check </td></tr>
    <tr><td class="paramname">TResult</td><td>The expected return type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaebcb92033ac39792270f5d34b7bcbd80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebcb92033ac39792270f5d34b7bcbd80">&#9670;&nbsp;</a></span>logically_combinable_with</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLhs , class TRhs &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept sl::concepts::logically_combinable_with</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= conjunctive_with&lt;TLhs, TRhs&gt;</div>
<div class="line">                                        &amp;&amp; disjunctive_with&lt;TLhs, TRhs&gt;</div>
<div class="line">                                        &amp;&amp; exclusive_disjunctive_with&lt;TLhs, TRhs&gt;</div>
</div><!-- fragment -->
<p>Determines whether two types can be used in operator &amp;, | amd ^ expressions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TLhs</td><td>The left-hand-side type </td></tr>
    <tr><td class="paramname">TRhs</td><td>the right-hand-side-type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga842ed63a2882193b04c7c295603b9a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga842ed63a2882193b04c7c295603b9a97">&#9670;&nbsp;</a></span>logically_combinable_with_r</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLhs , class TRhs , class TResult  = std::remove_cvref_t&lt;TLhs&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept sl::concepts::logically_combinable_with_r</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= conjunctive_with_r&lt;TLhs, TRhs, TResult&gt;</div>
<div class="line">                                        &amp;&amp; disjunctive_with_r&lt;TLhs, TRhs, TResult&gt;</div>
<div class="line">                                        &amp;&amp; exclusive_disjunctive_with_r&lt;TLhs, TRhs, TResult&gt;</div>
</div><!-- fragment -->
<p>Determines whether two types can be used in operator &amp;, | amd ^ expressions and if the return type is convertible to the expected one. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TLhs</td><td>The left-hand-side type </td></tr>
    <tr><td class="paramname">TRhs</td><td>the right-hand-side-type </td></tr>
    <tr><td class="paramname">TResult</td><td>The expected return type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
