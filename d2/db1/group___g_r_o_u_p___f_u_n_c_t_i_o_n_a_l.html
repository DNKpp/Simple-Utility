<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simple-Utility: functional</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Simple-Utility<span id="projectnumber">&#160;v2.2.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#concepts">Concepts</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">functional</div></div>
</div><!--header-->
<div class="contents">

<p>This namespace contains helper types for complex functional chaining and concrete functional objects.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for functional:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.svg" width="276" height="507"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:d5/dc1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___a_r_i_t_h_m_e_t_i_c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___a_r_i_t_h_m_e_t_i_c.html">arithmetic</a></td></tr>
<tr class="memdesc:d5/dc1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___a_r_i_t_h_m_e_t_i_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains functional objects, implementing several arithmetically operations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d0/d96/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___c_l_o_s_u_r_e___t_e_m_p_l_a_t_e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d96/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___c_l_o_s_u_r_e___t_e_m_p_l_a_t_e.html">closure_template</a></td></tr>
<tr class="memdesc:d0/d96/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___c_l_o_s_u_r_e___t_e_m_p_l_a_t_e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait type, exposing the closure template. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:de/d23/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___c_o_m_p_a_r_e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d23/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___c_o_m_p_a_r_e.html">compare</a></td></tr>
<tr class="memdesc:de/d23/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___c_o_m_p_a_r_e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains various comparision predicates. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d9/db2/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___c_o_m_p_o_s_i_t_i_o_n"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/db2/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___c_o_m_p_o_s_i_t_i_o_n.html">composition</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d9/d07/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___i_n_v_o_k_e___p_o_l_i_c_y"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d07/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___i_n_v_o_k_e___p_o_l_i_c_y.html">invoke policy</a></td></tr>
<tr class="memdesc:d9/d07/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___i_n_v_o_k_e___p_o_l_i_c_y"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains several CRTP types, decorating the behavior of functional types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dc/d1e/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___p_r_e_d_i_c_a_t_e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d1e/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___p_r_e_d_i_c_a_t_e.html">predicate</a></td></tr>
<tr class="memdesc:dc/d1e/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___p_r_e_d_i_c_a_t_e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the <code>Predicate</code> closure template. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:df/db2/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___t_r_a_n_s_f_o_r_m"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/db2/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___t_r_a_n_s_f_o_r_m.html">transform</a></td></tr>
<tr class="memdesc:df/db2/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___t_r_a_n_s_f_o_r_m"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the <code>Transform</code> closure template. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dc/dc2/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___t_u_p_l_e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dc2/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___t_u_p_l_e.html">tuple</a></td></tr>
<tr class="memdesc:dc/dc2/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___t_u_p_l_e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains several tuple related <code>Transform</code> definitions and the <code>Apply</code> closure template. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:de/d3a/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___u_n_w_r_a_p___f_u_n_c_t_i_o_n_a_l"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d3a/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___u_n_w_r_a_p___f_u_n_c_t_i_o_n_a_l.html">unwrap_functional</a></td></tr>
<tr class="memdesc:de/d3a/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___u_n_w_r_a_p___f_u_n_c_t_i_o_n_a_l"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait, unwrapping the functional type if a closure type is given, otherwise the given type. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:de/d1c/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___u_t_i_l_i_t_y"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1c/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___u_t_i_l_i_t_y.html">utility</a></td></tr>
<tr class="memdesc:de/d1c/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___u_t_i_l_i_t_y"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains functional objects, implementing several utility operations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/conceptsl_1_1functional_1_1function.html">sl::functional::function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given type satisfies the constraints of a function type. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d2f/conceptsl_1_1functional_1_1invoke__policy.html">sl::functional::invoke_policy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given type satisfies the constraints of an invoke-policy. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d67/conceptsl_1_1functional_1_1operator__policy.html">sl::functional::operator_policy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given type satisfies the constraints of a operator-policy. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d3b/classsl_1_1functional_1_1_basic_closure.html">sl::functional::BasicClosure&lt; Fn, InvokePolicy, OperatorPolicies &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The core class, wrapping one functional object and enabling a variety of composing operators for it.  <a href="../../d6/d3b/classsl_1_1functional_1_1_basic_closure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de3/structsl_1_1functional_1_1_overloaded.html">sl::functional::Overloaded&lt; Fns &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper invocable type which can hold an arbitrary amount of functions, from which the best match will be selected during invocation.  <a href="../../d3/de3/structsl_1_1functional_1_1_overloaded.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga1691942224a78210ecd7e80b477bfe9c"><td class="memTemplParams" colspan="2">template&lt;function Fn&gt; </td></tr>
<tr class="memitem:ga1691942224a78210ecd7e80b477bfe9c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga1691942224a78210ecd7e80b477bfe9c">sl::functional::Apply</a> = <a class="el" href="../../d6/d3b/classsl_1_1functional_1_1_basic_closure.html">BasicClosure</a>&lt; Fn, <a class="el" href="../../d9/d07/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___i_n_v_o_k_e___p_o_l_i_c_y.html#ga8c45523924e7a388fee3d93ce0a9036e">NodiscardApplyPolicy</a>, <a class="el" href="../../d5/de6/classsl_1_1functional_1_1_pipe_operator.html">PipeOperator</a> &gt;</td></tr>
<tr class="memdesc:ga1691942224a78210ecd7e80b477bfe9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a functional and forwards elements from provided tuples as params on invocation.  <br /></td></tr>
<tr class="separator:ga1691942224a78210ecd7e80b477bfe9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga17e74db9ae44364a3c1914ebfd1cb39b"><td class="memTemplParams" colspan="2">template&lt;class Fn &gt; </td></tr>
<tr class="memitem:ga17e74db9ae44364a3c1914ebfd1cb39b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../de/d3a/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___u_n_w_r_a_p___f_u_n_c_t_i_o_n_a_l.html#gafba5ec9fa6139a073aae5f72fae73b0e">unwrap_functional_t</a>&lt; Fn &amp;&amp; &gt; &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga17e74db9ae44364a3c1914ebfd1cb39b">sl::functional::forward_unwrapped</a> (std::remove_reference_t&lt; Fn &gt; &amp;fn) noexcept</td></tr>
<tr class="memdesc:ga17e74db9ae44364a3c1914ebfd1cb39b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unwraps the functional if stored in a closure. Otherwise forwards as-is.  <br /></td></tr>
<tr class="separator:ga17e74db9ae44364a3c1914ebfd1cb39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a0bba4d8e58e928d195ec7da8be29af"><td class="memTemplParams" colspan="2">template&lt;template&lt; class &gt; class Closure, class Fn &gt; </td></tr>
<tr class="memitem:ga8a0bba4d8e58e928d195ec7da8be29af"><td class="memTemplItemLeft" align="right" valign="top">constexpr Closure&lt; std::remove_cvref_t&lt; Fn &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga8a0bba4d8e58e928d195ec7da8be29af">sl::functional::envelop</a> (Fn &amp;&amp;fn) noexcept(std::is_nothrow_constructible_v&lt; std::remove_cvref_t&lt; Fn &gt;, Fn &gt;)</td></tr>
<tr class="memdesc:ga8a0bba4d8e58e928d195ec7da8be29af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the given functional into the given closure type.  <br /></td></tr>
<tr class="separator:ga8a0bba4d8e58e928d195ec7da8be29af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fe3967400664473cf993d977111f7f4"><td class="memTemplParams" colspan="2">template&lt;class... Fns&gt; </td></tr>
<tr class="memitem:ga0fe3967400664473cf993d977111f7f4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga0fe3967400664473cf993d977111f7f4">sl::functional::Overloaded</a> (Fns...) -&gt; <a class="el" href="../../d3/de3/structsl_1_1functional_1_1_overloaded.html">Overloaded</a>&lt; Fns... &gt;</td></tr>
<tr class="memdesc:ga0fe3967400664473cf993d977111f7f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide of overloaded type.  <br /></td></tr>
<tr class="separator:ga0fe3967400664473cf993d977111f7f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga2ad6b2671ab9248c51cfaee25af347e8"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga2ad6b2671ab9248c51cfaee25af347e8">sl::functional::bind_back</a></td></tr>
<tr class="memdesc:ga2ad6b2671ab9248c51cfaee25af347e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function, which generates a forwarding call wrapper for the given function and curries the params beginning at the back.  <br /></td></tr>
<tr class="separator:ga2ad6b2671ab9248c51cfaee25af347e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This namespace contains helper types for complex functional chaining and concrete functional objects. </p>
<p>As working more and more with <code>ranges</code> and functional style approach, this library is designed to fully support the programmers in such cases.</p>
<p>This namespaces aims to simplify caller code, when supplying algorithm with user provided function objects. Therefore several types are offered, which enable different composition operations. Which one exactly, depends on the concrete closure template.</p>
<dl class="section note"><dt>Note</dt><dd>The wrapped function serves only as an enabler for the composition operators. Once a composition has been started, any type of functional may be provided.</dd></dl>
<h1><a class="anchor" id="autotoc_md0"></a>
Transform closure</h1>
<p>The transform part of this library is designed to help the programmer when working with <code>ranges</code> or any other algorithm, which accepts a functional as part of its interface. There is often the need to apply multiple sub-steps on a value, before the work is actually done. Because of this many existing functions are not usable by their own, thus they must be wrapped into a lambda, which results in quite a bit of noise. With objects of type <code>Transform</code> programmers have the option to pipe function results into other functions, and thus nest multiple functions into each other. </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> composition = sf::envelop&lt;sf::Transform&gt;([](<span class="keyword">const</span> <span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x + 42; })</div>
<div class="line">                        | [](<span class="keyword">const</span> <span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> std::to_string(x); };</div>
<div class="line"> </div>
<div class="line">    REQUIRE(composition(1) == <span class="stringliteral">&quot;43&quot;</span>);</div>
</div><!-- fragment --><p> <code>sf::envelop</code> is a simple factory function, which hands over the given functional to the <code>Transform</code> template, so users don't have to supply the actual template params (CTAD unfortunately isn't a thing yet for typedefs...).</p>
<p><code>composition</code> is equivalent to </p><div class="fragment"><div class="line">[](<span class="keyword">const</span> <span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> std::to_string(i + 42); };</div>
</div><!-- fragment --><p>Sure, that seems to be a lot more effort for this trivial task, but this approach lets you compose existing features into more complex ones. Have a look at the next example, where we pre-define the <code>to_string</code> in forehand: </p><div class="fragment"><div class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> to_string = sf::envelop&lt;sf::Transform&gt;([](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; x) { <span class="keywordflow">return</span> std::to_string(x); });</div>
</div><!-- fragment --><div class="fragment"><div class="line">    std::vector&lt;std::string&gt; strings{};</div>
<div class="line">    std::ranges::transform(</div>
<div class="line">        std::array{42, 43, 44},</div>
<div class="line">        std::back_inserter(strings),</div>
<div class="line">        sf::arithmetic::negate</div>
<div class="line">        | std::bind_front(std::multiplies{}, 2)</div>
<div class="line">        | to_string</div>
<div class="line">        | [i{0}](<span class="keyword">const</span> std::string&amp; str) <span class="keyword">mutable</span> { <span class="keywordflow">return</span> <span class="stringliteral">&quot;value#&quot;</span> + std::to_string(++i) + <span class="stringliteral">&quot; is = &quot;</span> + str; });</div>
<div class="line"> </div>
<div class="line">    REQUIRE_THAT(</div>
<div class="line">        strings,</div>
<div class="line">        Catch::Matchers::RangeEquals(std::array{</div>
<div class="line">            <span class="stringliteral">&quot;value#1 is = -84&quot;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;value#2 is = -86&quot;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;value#3 is = -88&quot;</span></div>
<div class="line">            }));</div>
</div><!-- fragment --><p> We create a range of integer values and transform these into strings (NOTE: <code>std::format</code> was no option on gcc at the time of writing). We first negate the values, multiply the result by two, transform them to a string and then formulate a sentence with them. As you can see, once the pipe is active, one can chain any type of functional; even mutable lambdas are supported!</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Predicate closure</h1>
<p><code>Predicate</code> objects are fully compatible with <code>Transform</code> objects, thus they may be mixed as desired. Additionally they offer composing via operator &amp;&amp;, || and other common operations. Other than piping, all such composed predicates will receive the identically input and are required to return boolean convertible results. Eventually <code>Predicate</code> are easily invertible via operator !.</p>
<p>Let there be a pre-defined predicate <code>is_even</code>: </p><div class="fragment"><div class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> is_even = sf::envelop&lt;sf::Predicate&gt;([](<span class="keyword">const</span> std::integral <span class="keyword">auto</span>&amp; x) { <span class="keywordflow">return</span> x % 2 == 0; });</div>
</div><!-- fragment --><p> You can combine predicates in various ways and therefore create much more complex predicates. For example, this snippet filters values which are even and less than 44 OR odd and greater than 45. The usual operator precedences apply here as-well. </p><div class="fragment"><div class="line">    std::vector&lt;int&gt; values{};</div>
<div class="line">    std::ranges::copy_if(</div>
<div class="line">        std::array{42, 43, 44, 45, 46, 47},</div>
<div class="line">        std::back_inserter(values),</div>
<div class="line">        is_even &amp;&amp; sf::bind_back(std::less{}, 44)</div>
<div class="line">        || !is_even &amp;&amp; sf::bind_back(std::greater{}, 45));</div>
<div class="line"> </div>
<div class="line">    REQUIRE_THAT(</div>
<div class="line">        values,</div>
<div class="line">        Catch::Matchers::RangeEquals(std::array{42, 47}));</div>
</div><!-- fragment --> <h2 class="groupheader">Typedef Documentation</h2>
<a id="ga1691942224a78210ecd7e80b477bfe9c" name="ga1691942224a78210ecd7e80b477bfe9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1691942224a78210ecd7e80b477bfe9c">&#9670;&#160;</a></span>Apply</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;function Fn&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga1691942224a78210ecd7e80b477bfe9c">sl::functional::Apply</a> = typedef <a class="el" href="../../d6/d3b/classsl_1_1functional_1_1_basic_closure.html">BasicClosure</a>&lt;Fn, <a class="el" href="../../d9/d07/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___i_n_v_o_k_e___p_o_l_i_c_y.html#ga8c45523924e7a388fee3d93ce0a9036e">NodiscardApplyPolicy</a>, <a class="el" href="../../d5/de6/classsl_1_1functional_1_1_pipe_operator.html">PipeOperator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores a functional and forwards elements from provided tuples as params on invocation. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga8a0bba4d8e58e928d195ec7da8be29af" name="ga8a0bba4d8e58e928d195ec7da8be29af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a0bba4d8e58e928d195ec7da8be29af">&#9670;&#160;</a></span>envelop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; class Closure, class Fn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Closure&lt; std::remove_cvref_t&lt; Fn &gt; &gt; sl::functional::envelop </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the given functional into the given closure type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Fn</td><td>The functional type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>The functional to be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The wrapped functional. </dd></dl>

</div>
</div>
<a id="ga17e74db9ae44364a3c1914ebfd1cb39b" name="ga17e74db9ae44364a3c1914ebfd1cb39b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17e74db9ae44364a3c1914ebfd1cb39b">&#9670;&#160;</a></span>forward_unwrapped()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Fn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../de/d3a/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___u_n_w_r_a_p___f_u_n_c_t_i_o_n_a_l.html#gafba5ec9fa6139a073aae5f72fae73b0e">unwrap_functional_t</a>&lt; Fn &amp;&amp; &gt; &amp;&amp; sl::functional::forward_unwrapped </td>
          <td>(</td>
          <td class="paramtype">std::remove_reference_t&lt; Fn &gt; &amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unwraps the functional if stored in a closure. Otherwise forwards as-is. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Fn</td><td>The functional type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>The functional to be unwrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unwrapped functional. </dd></dl>

</div>
</div>
<a id="ga0fe3967400664473cf993d977111f7f4" name="ga0fe3967400664473cf993d977111f7f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fe3967400664473cf993d977111f7f4">&#9670;&#160;</a></span>Overloaded()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Fns&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/de3/structsl_1_1functional_1_1_overloaded.html">sl::functional::Overloaded</a> </td>
          <td>(</td>
          <td class="paramtype">Fns...&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="../../d3/de3/structsl_1_1functional_1_1_overloaded.html">Overloaded</a>&lt; Fns... &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide of overloaded type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Fns</td><td>The function types. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga2ad6b2671ab9248c51cfaee25af347e8" name="ga2ad6b2671ab9248c51cfaee25af347e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ad6b2671ab9248c51cfaee25af347e8">&#9670;&#160;</a></span>bind_back</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto sl::functional::bind_back</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= []&lt;<span class="keyword">class </span>Fn, class... BoundArgs&gt;(</div>
<div class="line">        Fn&amp;&amp; func,</div>
<div class="line">        BoundArgs&amp;&amp;... boundArgs</div>
<div class="line">    ) <span class="keyword">noexcept</span>(std::is_nothrow_constructible_v&lt;std::remove_cvref_t&lt;Fn&gt;, Fn&gt;</div>
<div class="line">                &amp;&amp; (... &amp;&amp; std::is_nothrow_constructible_v&lt;std::unwrap_ref_decay_t&lt;BoundArgs&gt;, BoundArgs&gt;))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> detail::BindBack{std::forward&lt;Fn&gt;(func), std::forward&lt;BoundArgs&gt;(boundArgs)...};</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Helper function, which generates a forwarding call wrapper for the given function and curries the params beginning at the back. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
