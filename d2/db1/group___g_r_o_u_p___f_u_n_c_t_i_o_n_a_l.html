<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simple-Utility: functional</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Simple-Utility<span id="projectnumber">&#160;v2.2.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">functional</div></div>
</div><!--header-->
<div class="contents">

<p>This namespace contains helper types for complex functional chaining and concrete functional objects.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for functional:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.svg" width="259" height="332"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:d5/dc1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___a_r_i_t_h_m_e_t_i_c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___a_r_i_t_h_m_e_t_i_c.html">arithmetic</a></td></tr>
<tr class="memdesc:d5/dc1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___a_r_i_t_h_m_e_t_i_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains functional objects, implementing several arithmetically operations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:de/d23/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___c_o_m_p_a_r_e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d23/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___c_o_m_p_a_r_e.html">compare</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d1/d53/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___o_p_e_r_a_t_o_r_s"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d53/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___o_p_e_r_a_t_o_r_s.html">operators</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dc/d1e/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___p_r_e_d_i_c_a_t_e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d1e/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___p_r_e_d_i_c_a_t_e.html">predicate</a></td></tr>
<tr class="memdesc:dc/d1e/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___p_r_e_d_i_c_a_t_e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the base <code><a class="el" href="../../df/d86/classsl_1_1functional_1_1predicate__fn.html" title="Adapter type for predicates, which accepts a functional type and enables pipe, conjunctive and disjun...">predicate_fn</a></code> and several pre-defined predicate objects. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:df/db2/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___t_r_a_n_s_f_o_r_m"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/db2/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___t_r_a_n_s_f_o_r_m.html">transform</a></td></tr>
<tr class="memdesc:df/db2/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___t_r_a_n_s_f_o_r_m"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the base <code><a class="el" href="../../da/dbe/classsl_1_1functional_1_1transform__fn.html" title="Adapter type which accepts a functional type and enables pipe chaining and currying.">transform_fn</a></code> and several pre-defined transform objects. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dc/dc2/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___t_u_p_l_e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dc2/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___t_u_p_l_e.html">tuple functional</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:de/d1c/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___u_t_i_l_i_t_y"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1c/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___u_t_i_l_i_t_y.html">utility</a></td></tr>
<tr class="memdesc:de/d1c/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l___u_t_i_l_i_t_y"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains functional objects, implementing several utility operations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/de4/classsl_1_1functional_1_1closure__base__fn.html">sl::functional::closure_base_fn&lt; TFunc &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type which simply stores functional objects or function pointers.  <a href="../../d9/de4/classsl_1_1functional_1_1closure__base__fn.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d09/classsl_1_1functional_1_1composition__fn.html">sl::functional::composition_fn&lt; TOperation, TFunctions &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functional type, which composes multiple functional objects via the given operation.  <a href="../../d9/d09/classsl_1_1functional_1_1composition__fn.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d72/classsl_1_1functional_1_1value__fn.html">sl::functional::value_fn&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functional helper type, which takes a value and returns them on invocation.  <a href="../../da/d72/classsl_1_1functional_1_1value__fn.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d50/structsl_1_1functional_1_1enable__operation.html">sl::functional::enable_operation&lt; TClosureTemplate, TOperationTags &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/da3/structsl_1_1functional_1_1overloaded.html">sl::functional::overloaded&lt; TFunctions &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper invocable type which can hold an arbitrary amount of functions, from which the best match will be selected during invocation.  <a href="../../d8/da3/structsl_1_1functional_1_1overloaded.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga219bf23f133d37fe64c6b69ef399bf53"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga219bf23f133d37fe64c6b69ef399bf53"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga219bf23f133d37fe64c6b69ef399bf53">sl::functional::closure_function_t</a> = typename std::remove_cvref_t&lt; T &gt;::function_type</td></tr>
<tr class="separator:ga219bf23f133d37fe64c6b69ef399bf53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dd4cd323a9e290ee4c781c84e44b5f9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga3dd4cd323a9e290ee4c781c84e44b5f9">sl::functional::composition_fn&lt; TOperation, TFunctions &gt;::function_storage_t</a> = std::tuple&lt; TFunctions... &gt;</td></tr>
<tr class="separator:ga3dd4cd323a9e290ee4c781c84e44b5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f6f3e0dc472f0ac24160939731d84ea"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga2f6f3e0dc472f0ac24160939731d84ea">sl::functional::composition_fn&lt; TOperation, TFunctions &gt;::operation_t</a> = TOperation</td></tr>
<tr class="separator:ga2f6f3e0dc472f0ac24160939731d84ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9ee1b452aa1643df2ca99f880ce68c5a"><td class="memTemplParams" colspan="2">template&lt;class TFunc &gt; </td></tr>
<tr class="memitem:ga9ee1b452aa1643df2ca99f880ce68c5a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga9ee1b452aa1643df2ca99f880ce68c5a">sl::functional::closure_base_fn</a> (TFunc) -&gt; <a class="el" href="../../d9/de4/classsl_1_1functional_1_1closure__base__fn.html">closure_base_fn</a>&lt; TFunc &gt;</td></tr>
<tr class="memdesc:ga9ee1b452aa1643df2ca99f880ce68c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga9ee1b452aa1643df2ca99f880ce68c5a">More...</a><br /></td></tr>
<tr class="separator:ga9ee1b452aa1643df2ca99f880ce68c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fda180de7af581034aa963d3d261205"><td class="memTemplParams" colspan="2">template&lt;concepts::initializes&lt; <a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga2f6f3e0dc472f0ac24160939731d84ea">operation_t</a> &gt; TOperationArg, class... TFunctionArgs&gt; <br />
requires std::constructible_from&lt;<a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga3dd4cd323a9e290ee4c781c84e44b5f9">function_storage_t</a>, detail::unwrap_functional_r_t&lt;TFunctionArgs&gt;...&gt;</td></tr>
<tr class="memitem:ga8fda180de7af581034aa963d3d261205"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga8fda180de7af581034aa963d3d261205">sl::functional::composition_fn&lt; TOperation, TFunctions &gt;::composition_fn</a> (TOperationArg &amp;&amp;operationArg, TFunctionArgs &amp;&amp;... functionArgs) noexcept(std::is_nothrow_constructible_v&lt; <a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga2f6f3e0dc472f0ac24160939731d84ea">operation_t</a>, TOperationArg &gt; &amp;&amp;(std::is_nothrow_constructible_v&lt; TFunctions, detail::unwrap_functional_r_t&lt; TFunctionArgs &gt; &gt; &amp;&amp;...))</td></tr>
<tr class="separator:ga8fda180de7af581034aa963d3d261205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40fb6b4418951b49ec2216a1e2565aec"><td class="memTemplParams" colspan="2">template&lt;class... TCallArgs&gt; <br />
requires std::invocable&lt;const <a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga2f6f3e0dc472f0ac24160939731d84ea">operation_t</a>&amp;, std::tuple&lt;TCallArgs...&gt;, const TFunctions&amp;...&gt;</td></tr>
<tr class="memitem:ga40fb6b4418951b49ec2216a1e2565aec"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga40fb6b4418951b49ec2216a1e2565aec">sl::functional::composition_fn&lt; TOperation, TFunctions &gt;::operator()</a> (TCallArgs &amp;&amp;... callArgs) const &amp;noexcept(std::is_nothrow_invocable_v&lt; const <a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga2f6f3e0dc472f0ac24160939731d84ea">operation_t</a> &amp;, std::tuple&lt; TCallArgs... &gt;, const TFunctions &amp;... &gt;)</td></tr>
<tr class="separator:ga40fb6b4418951b49ec2216a1e2565aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c0bce87c35413d84201d11787405b87"><td class="memTemplParams" colspan="2">template&lt;class... TCallArgs&gt; <br />
requires std::invocable&lt;<a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga2f6f3e0dc472f0ac24160939731d84ea">operation_t</a>&amp;, std::tuple&lt;TCallArgs...&gt;, TFunctions&amp;...&gt;</td></tr>
<tr class="memitem:ga1c0bce87c35413d84201d11787405b87"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga1c0bce87c35413d84201d11787405b87">sl::functional::composition_fn&lt; TOperation, TFunctions &gt;::operator()</a> (TCallArgs &amp;&amp;... callArgs) &amp;noexcept(std::is_nothrow_invocable_v&lt; <a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga2f6f3e0dc472f0ac24160939731d84ea">operation_t</a> &amp;, std::tuple&lt; TCallArgs... &gt;, TFunctions &amp;... &gt;)</td></tr>
<tr class="separator:ga1c0bce87c35413d84201d11787405b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga009da8b327da0a484c64677de5423363"><td class="memTemplParams" colspan="2">template&lt;class... TCallArgs&gt; <br />
requires std::invocable&lt;<a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga2f6f3e0dc472f0ac24160939731d84ea">operation_t</a>&amp;&amp;, std::tuple&lt;TCallArgs...&gt;, TFunctions&amp;&amp;...&gt;</td></tr>
<tr class="memitem:ga009da8b327da0a484c64677de5423363"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga009da8b327da0a484c64677de5423363">sl::functional::composition_fn&lt; TOperation, TFunctions &gt;::operator()</a> (TCallArgs &amp;&amp;... callArgs) &amp;&amp;noexcept(std::is_nothrow_invocable_v&lt; <a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga2f6f3e0dc472f0ac24160939731d84ea">operation_t</a> &amp;&amp;, std::tuple&lt; TCallArgs... &gt;, TFunctions &amp;&amp;... &gt;)</td></tr>
<tr class="separator:ga009da8b327da0a484c64677de5423363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5315afa8605ee314352cad719cc155a8"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga3dd4cd323a9e290ee4c781c84e44b5f9">function_storage_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga5315afa8605ee314352cad719cc155a8">sl::functional::composition_fn&lt; TOperation, TFunctions &gt;::operator*</a> () const &amp;noexcept(std::is_nothrow_copy_constructible_v&lt; <a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga3dd4cd323a9e290ee4c781c84e44b5f9">function_storage_t</a> &gt;)</td></tr>
<tr class="separator:ga5315afa8605ee314352cad719cc155a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63a13a43133b9aafa24678d283b25800"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga3dd4cd323a9e290ee4c781c84e44b5f9">function_storage_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga63a13a43133b9aafa24678d283b25800">sl::functional::composition_fn&lt; TOperation, TFunctions &gt;::operator*</a> () &amp;&amp;noexcept(std::is_nothrow_move_constructible_v&lt; <a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga3dd4cd323a9e290ee4c781c84e44b5f9">function_storage_t</a> &gt;)</td></tr>
<tr class="separator:ga63a13a43133b9aafa24678d283b25800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac330b28c93020dd9d1585031aa074639"><td class="memTemplParams" colspan="2">template&lt;class TOperation , class... TFunctions&gt; </td></tr>
<tr class="memitem:gac330b28c93020dd9d1585031aa074639"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#gac330b28c93020dd9d1585031aa074639">sl::functional::composition_fn</a> (TOperation, TFunctions...) -&gt; <a class="el" href="../../d9/d09/classsl_1_1functional_1_1composition__fn.html">composition_fn</a>&lt; TOperation, detail::unwrap_functional_r_t&lt; TFunctions &gt;... &gt;</td></tr>
<tr class="memdesc:gac330b28c93020dd9d1585031aa074639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#gac330b28c93020dd9d1585031aa074639">More...</a><br /></td></tr>
<tr class="separator:gac330b28c93020dd9d1585031aa074639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a5f398f6bc226fda5d50e52a53130fb"><td class="memTemplParams" colspan="2">template&lt;class TValue &gt; </td></tr>
<tr class="memitem:ga9a5f398f6bc226fda5d50e52a53130fb"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga9a5f398f6bc226fda5d50e52a53130fb">sl::functional::value_fn</a> (TValue) -&gt; <a class="el" href="../../da/d72/classsl_1_1functional_1_1value__fn.html">value_fn</a>&lt; TValue &gt;</td></tr>
<tr class="memdesc:ga9a5f398f6bc226fda5d50e52a53130fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga9a5f398f6bc226fda5d50e52a53130fb">More...</a><br /></td></tr>
<tr class="separator:ga9a5f398f6bc226fda5d50e52a53130fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga974f4862e98814664301ccefb0e36bb5"><td class="memTemplParams" colspan="2">template&lt;class... TFunctions&gt; </td></tr>
<tr class="memitem:ga974f4862e98814664301ccefb0e36bb5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga974f4862e98814664301ccefb0e36bb5">sl::functional::overloaded</a> (TFunctions...) -&gt; <a class="el" href="../../d8/da3/structsl_1_1functional_1_1overloaded.html">overloaded</a>&lt; TFunctions... &gt;</td></tr>
<tr class="memdesc:ga974f4862e98814664301ccefb0e36bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide of overloaded type.  <a href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga974f4862e98814664301ccefb0e36bb5">More...</a><br /></td></tr>
<tr class="separator:ga974f4862e98814664301ccefb0e36bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga6ecccc3d30a49c358c1e43ee4a77f5a2"><td class="memTemplParams" colspan="2">template&lt;operators::tag TOperationTag, class... TFunctions&gt; </td></tr>
<tr class="memitem:ga6ecccc3d30a49c358c1e43ee4a77f5a2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga6ecccc3d30a49c358c1e43ee4a77f5a2">sl::functional::is_nothrow_composable_v</a></td></tr>
<tr class="separator:ga6ecccc3d30a49c358c1e43ee4a77f5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >This namespace contains helper types for complex functional chaining and concrete functional objects. </p>
<p >As working more and more with <code>ranges</code> and functional style approach, this library is designed to fully support the programmers in such cases.</p>
<p >This namespaces aims to simplify caller code, when supplying algorithm with user provided function objects. Therefore several types are offered, which enable different composition modes.</p>
<h1><a class="anchor" id="autotoc_md0"></a>
transform</h1>
<p >The transform part of this library is designed to help the programmer when working with <code>ranges</code> or any other algorithm, which accepts a functional as part of its interface. There is often the need to do multiple steps before the work is actually done. Because of this many existing functional objects are not usable by their own, thus they must be wrapped into a lambda, which results in quite a bit of noise. With objects of type <code><a class="el" href="../../da/dbe/classsl_1_1functional_1_1transform__fn.html" title="Adapter type which accepts a functional type and enables pipe chaining and currying.">transform_fn</a></code> programmers have the option to pipe function results into other functions, and thus nest multiple functions into each other. </p><div class="fragment"><div class="line">    transform_fn comp = transform_fn{add42}</div>
<div class="line">                        | [](<span class="keyword">const</span> <span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> std::to_string(x); };</div>
<div class="line"> </div>
<div class="line">    REQUIRE(comp(1) == <span class="stringliteral">&quot;43&quot;</span>);</div>
</div><!-- fragment --><p> <code>comp</code> is equivalent to </p><div class="fragment"><div class="line">[](<span class="keyword">const</span> <span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> std::to_string(i + 42); };</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1"></a>
predicates</h1>
<p ><code><a class="el" href="../../df/d86/classsl_1_1functional_1_1predicate__fn.html" title="Adapter type for predicates, which accepts a functional type and enables pipe, conjunctive and disjun...">predicate_fn</a></code> objects are fully compatible with <code><a class="el" href="../../da/dbe/classsl_1_1functional_1_1transform__fn.html" title="Adapter type which accepts a functional type and enables pipe chaining and currying.">transform_fn</a></code> objects, thus they may be mixed as desired. Additionally they offer composing via operator &amp;&amp;, || and other common operations. Other than piping, all such composed predicates will receive the identically input and are required to return boolean convertible results. Finally <code><a class="el" href="../../df/d86/classsl_1_1functional_1_1predicate__fn.html" title="Adapter type for predicates, which accepts a functional type and enables pipe, conjunctive and disjun...">predicate_fn</a></code> are easily invertible via operator !.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
currying</h1>
<p >When working in functional style, there also often exists the desire to curry existing function objects, before giving them out of hands. This library supports this currently in two styles:</p><ul>
<li>front currying via operator &lt;&lt; (points to the front)</li>
<li>back currying via operator &lt;&lt; (points to the back)</li>
</ul>
<p >Users are free to use them both on the same functional, but this will soon lead to non-obvious behaviour when mixing too arbitrarily. The library tries to keep the call stack as flat as possible and therefore combines multiple binds with equally directions into one final composition. When mixing them up like </p><div class="fragment"><div class="line">myTransform &lt;&lt; 42 &gt;&gt; 1337 &lt;&lt; <span class="stringliteral">&quot;Hello, World!&quot;</span> &gt;&gt; 3.1415;</div>
</div><!-- fragment --><p> the result will be not as good as it could. The code will still work; a semantically equal but a better optimized (and readable) solution would be something like this: </p><div class="fragment"><div class="line">myTransform &lt;&lt; 42 &lt;&lt; <span class="stringliteral">&quot;Hello, World!&quot;</span> &gt;&gt; 3.1415 &gt;&gt; 1337;</div>
</div><!-- fragment --><p> Note how the ordering of the two back-bound-values changed (which is the ordering readers understand probably best).</p>
<p >Values will usually be bound by value, but users may wrap their values into <code>std::reference_wrapper</code>, which will then be unwrapped during invocation and thus provided as (const) lvalue-reference to the invoked function(s). </p><div class="fragment"><div class="line">    <span class="keywordtype">int</span> x{42};</div>
<div class="line">    value_fn value{std::ref(x)};</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span>&amp; x_ref = std::invoke(TestType::cast(value));</div>
<div class="line">    x_ref = 1337;</div>
<div class="line"> </div>
<div class="line">    REQUIRE(x == 1337);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The library classes are designed to only accept functional objects or pointers as value. This usually works fine but may lead to surprisingly effects when working with mutable lambdas or other functional types. In those cases the functional object itself may be wrapped into a <code>std::reference_wrapper</code> before putting into the closure object. <div class="fragment"><div class="line">    <span class="keyword">const</span> std::vector sourceInts{0, 1, 2, 3};</div>
<div class="line">    <span class="keyword">auto</span> skipFirst = [i{0}](<span class="keyword">auto</span>&amp;&amp;...) <span class="keyword">mutable</span> { <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">bool</span><span class="keyword">&gt;</span>(i++); };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> result = std::ranges::count_if(</div>
<div class="line">        sourceInts,</div>
<div class="line">        predicate_fn{std::ref(skipFirst)}</div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    REQUIRE(result == 3);</div>
</div><!-- fragment --> </dd></dl>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga219bf23f133d37fe64c6b69ef399bf53" name="ga219bf23f133d37fe64c6b69ef399bf53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga219bf23f133d37fe64c6b69ef399bf53">&#9670;&#160;</a></span>closure_function_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga219bf23f133d37fe64c6b69ef399bf53">sl::functional::closure_function_t</a> = typedef typename std::remove_cvref_t&lt;T&gt;::function_type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga3dd4cd323a9e290ee4c781c84e44b5f9" name="ga3dd4cd323a9e290ee4c781c84e44b5f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3dd4cd323a9e290ee4c781c84e44b5f9">&#9670;&#160;</a></span>function_storage_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TOperation , class... TFunctions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d09/classsl_1_1functional_1_1composition__fn.html">sl::functional::composition_fn</a>&lt; TOperation, TFunctions &gt;::function_storage_t =  std::tuple&lt;TFunctions...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga2f6f3e0dc472f0ac24160939731d84ea" name="ga2f6f3e0dc472f0ac24160939731d84ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f6f3e0dc472f0ac24160939731d84ea">&#9670;&#160;</a></span>operation_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TOperation , class... TFunctions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d09/classsl_1_1functional_1_1composition__fn.html">sl::functional::composition_fn</a>&lt; TOperation, TFunctions &gt;::operation_t =  TOperation</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga8fda180de7af581034aa963d3d261205" name="ga8fda180de7af581034aa963d3d261205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fda180de7af581034aa963d3d261205">&#9670;&#160;</a></span>composition_fn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TOperation , class... TFunctions&gt; </div>
<div class="memtemplate">
template&lt;concepts::initializes&lt; <a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga2f6f3e0dc472f0ac24160939731d84ea">operation_t</a> &gt; TOperationArg, class... TFunctionArgs&gt; <br />
requires std::constructible_from&lt;<a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga3dd4cd323a9e290ee4c781c84e44b5f9">function_storage_t</a>, detail::unwrap_functional_r_t&lt;TFunctionArgs&gt;...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d09/classsl_1_1functional_1_1composition__fn.html">sl::functional::composition_fn</a>&lt; TOperation, TFunctions &gt;::composition_fn </td>
          <td>(</td>
          <td class="paramtype">TOperationArg &amp;&amp;&#160;</td>
          <td class="paramname"><em>operationArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFunctionArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>functionArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga9ee1b452aa1643df2ca99f880ce68c5a" name="ga9ee1b452aa1643df2ca99f880ce68c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ee1b452aa1643df2ca99f880ce68c5a">&#9670;&#160;</a></span>closure_base_fn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/de4/classsl_1_1functional_1_1closure__base__fn.html">sl::functional::closure_base_fn</a> </td>
          <td>(</td>
          <td class="paramtype">TFunc&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="../../d9/de4/classsl_1_1functional_1_1closure__base__fn.html">closure_base_fn</a>&lt; TFunc &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFunc</td><td>Type of the given value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac330b28c93020dd9d1585031aa074639" name="gac330b28c93020dd9d1585031aa074639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac330b28c93020dd9d1585031aa074639">&#9670;&#160;</a></span>composition_fn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TOperation , class... TFunctions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d09/classsl_1_1functional_1_1composition__fn.html">sl::functional::composition_fn</a> </td>
          <td>(</td>
          <td class="paramtype">TOperation&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFunctions...&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="../../d9/d09/classsl_1_1functional_1_1composition__fn.html">composition_fn</a>&lt; TOperation, detail::unwrap_functional_r_t&lt; TFunctions &gt;... &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TOperation</td><td>Type of the given operation type. </td></tr>
    <tr><td class="paramname">TFunctions</td><td>Type of the given functions type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga009da8b327da0a484c64677de5423363" name="ga009da8b327da0a484c64677de5423363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga009da8b327da0a484c64677de5423363">&#9670;&#160;</a></span>operator()() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TOperation , class... TFunctions&gt; </div>
<div class="memtemplate">
template&lt;class... TCallArgs&gt; <br />
requires std::invocable&lt;<a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga2f6f3e0dc472f0ac24160939731d84ea">operation_t</a>&amp;&amp;, std::tuple&lt;TCallArgs...&gt;, TFunctions&amp;&amp;...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) <a class="el" href="../../d9/d09/classsl_1_1functional_1_1composition__fn.html">sl::functional::composition_fn</a>&lt; TOperation, TFunctions &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">TCallArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>callArgs</em></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga1c0bce87c35413d84201d11787405b87" name="ga1c0bce87c35413d84201d11787405b87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c0bce87c35413d84201d11787405b87">&#9670;&#160;</a></span>operator()() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TOperation , class... TFunctions&gt; </div>
<div class="memtemplate">
template&lt;class... TCallArgs&gt; <br />
requires std::invocable&lt;<a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga2f6f3e0dc472f0ac24160939731d84ea">operation_t</a>&amp;, std::tuple&lt;TCallArgs...&gt;, TFunctions&amp;...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) <a class="el" href="../../d9/d09/classsl_1_1functional_1_1composition__fn.html">sl::functional::composition_fn</a>&lt; TOperation, TFunctions &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">TCallArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>callArgs</em></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga40fb6b4418951b49ec2216a1e2565aec" name="ga40fb6b4418951b49ec2216a1e2565aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40fb6b4418951b49ec2216a1e2565aec">&#9670;&#160;</a></span>operator()() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TOperation , class... TFunctions&gt; </div>
<div class="memtemplate">
template&lt;class... TCallArgs&gt; <br />
requires std::invocable&lt;const <a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga2f6f3e0dc472f0ac24160939731d84ea">operation_t</a>&amp;, std::tuple&lt;TCallArgs...&gt;, const TFunctions&amp;...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) <a class="el" href="../../d9/d09/classsl_1_1functional_1_1composition__fn.html">sl::functional::composition_fn</a>&lt; TOperation, TFunctions &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">TCallArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>callArgs</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga63a13a43133b9aafa24678d283b25800" name="ga63a13a43133b9aafa24678d283b25800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63a13a43133b9aafa24678d283b25800">&#9670;&#160;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TOperation , class... TFunctions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga3dd4cd323a9e290ee4c781c84e44b5f9">function_storage_t</a> <a class="el" href="../../d9/d09/classsl_1_1functional_1_1composition__fn.html">sl::functional::composition_fn</a>&lt; TOperation, TFunctions &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga5315afa8605ee314352cad719cc155a8" name="ga5315afa8605ee314352cad719cc155a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5315afa8605ee314352cad719cc155a8">&#9670;&#160;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TOperation , class... TFunctions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d2/db1/group___g_r_o_u_p___f_u_n_c_t_i_o_n_a_l.html#ga3dd4cd323a9e290ee4c781c84e44b5f9">function_storage_t</a> <a class="el" href="../../d9/d09/classsl_1_1functional_1_1composition__fn.html">sl::functional::composition_fn</a>&lt; TOperation, TFunctions &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga974f4862e98814664301ccefb0e36bb5" name="ga974f4862e98814664301ccefb0e36bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga974f4862e98814664301ccefb0e36bb5">&#9670;&#160;</a></span>overloaded()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... TFunctions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/da3/structsl_1_1functional_1_1overloaded.html">sl::functional::overloaded</a> </td>
          <td>(</td>
          <td class="paramtype">TFunctions...&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="../../d8/da3/structsl_1_1functional_1_1overloaded.html">overloaded</a>&lt; TFunctions... &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide of overloaded type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFunctions</td><td>The function types. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9a5f398f6bc226fda5d50e52a53130fb" name="ga9a5f398f6bc226fda5d50e52a53130fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a5f398f6bc226fda5d50e52a53130fb">&#9670;&#160;</a></span>value_fn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d72/classsl_1_1functional_1_1value__fn.html">sl::functional::value_fn</a> </td>
          <td>(</td>
          <td class="paramtype">TValue&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="../../da/d72/classsl_1_1functional_1_1value__fn.html">value_fn</a>&lt; TValue &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TValue</td><td>Type of the given value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga6ecccc3d30a49c358c1e43ee4a77f5a2" name="ga6ecccc3d30a49c358c1e43ee4a77f5a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ecccc3d30a49c358c1e43ee4a77f5a2">&#9670;&#160;</a></span>is_nothrow_composable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;operators::tag TOperationTag, class... TFunctions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool sl::functional::is_nothrow_composable_v</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">        std::is_nothrow_constructible_v&lt;operators::tag_operation_t&lt;TOperationTag&gt;&gt;</div>
<div class="line">        &amp;&amp; (detail::is_nothrow_constructible_helper&lt;std::remove_cvref_t&lt;TFunctions&gt;&gt;::value &amp;&amp; ...)</div>
<div class="line">    }</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
