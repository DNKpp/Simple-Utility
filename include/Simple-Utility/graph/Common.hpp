//          Copyright Dominic Koepke 2019 - 2023.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          https://www.boost.org/LICENSE_1_0.txt)

#ifndef SIMPLE_UTILITY_GRAPH_COMMON_HPP
#define SIMPLE_UTILITY_GRAPH_COMMON_HPP

#pragma once

#include "Simple-Utility/concepts/operators.hpp"
#include "Simple-Utility/concepts/stl_extensions.hpp"

#include <concepts>

/**
 * \defgroup GROUP_GRAPH graph
 *
 * \brief This library offers various graph related algorithms.
 * \details
 * # Design philosophy
 * This library is built completely on concepts, thus almost anything is exchangeable by users. Some parts may be worth the effort, some may not.
 * Symbols in ``detail`` namespace can be used, but are less secure and may require some more insights into the internals to be used correctly.
 *
 * The (as far as I'm aware of) unique core idea of this library is to *somehow* sort the vertices of an arbitrary graph as sequential range. The actual
 * algorithm then defines the *somehow* in an exchangeable manner.
 *
 * Many graph libraries utilize the visitor approach, where the visitor serves as the major customization point and gets notified about pre-defined
 * events during the whole algorithm runtime. These visitor may or may not be able to abort the algorithm, e.g. if they reached their goal. For example
 * boost requires the visitor throwing an exception (see [boost graph faq](https://www.boost.org/doc/libs/1_83_0/libs/graph/doc/faq.html)), which is not
 * what I would consider a clean design.
 *
 * The major issue I see with the visitor approach is, that this pollutes the actual algorithm with too much complexity, as it must be versatile enough to
 * satisfy any (or at least many) user requirements, while optimally disabling the optional features, the user does not need. It's really difficult to think about
 * any possible use-case the algorithm may be utilized for and then making it generic enough, while still offering top-notch performance, being versatile
 * and having a clean design.
 * The iterative approach of this library therefore concentrates on being a cursor into a graph and notifying the user about the currently referred vertex
 * (including possibly additional information). The users themselves can than decide how to proceed, e.g. if and how to store the yielded state or simply
 * throwing the whole algorithm state away, because the job is done. Having the algorithm state present as an actual object makes it trivial to run the
 * algorithm for a specific amount of steps (or until a predicate isn't satisfied, or whatever condition one may come up with) and continue later on.
 *
 * Nevertheless, this library neither aims to replace any existing graph library nor does it want to compete with them in performance regards. Other
 * libraries are (and probably stay) more feature rich, faster and more polished.
 *
 * ## Concepts
 * All algorithms utilize at least some of the general concepts. The term concept doesn't necessarily mean a c++ concept, its rather from a design perspective.
 * Nevertheless, most of these design concepts are indeed implemented as c++ concepts.
 *
 * ### Graph
 * A graph consists of multiple elements (vertices) and multiple edges. Most of the algorithms allow graphs to be dynamically explored during the traversal,
 * thus they can be generated on the fly.
 *
 * ### Vertex
 * A vertex denotes a unique graph element and is used by algorithms to query the graph for further information (e.g. neighboring vertices).
 *
 * ### Edges
 * A edge denotes a connection between two neighboring vertices of a graph and may contain a ``weight``, which is used by some algorithms, to select the best
 * alternatives out of the known edges.
 *
 * ### Node
 * A node is an info structure generated by traversing algorithms, which is used to keep track of the exploration state. After each exploration step the current
 * node is returned to the caller, which may cache it in its own container or simply throw it away.
 *
 * Nodes consist of at least a vertex, which they are related to, but may also contain additional information provided by the algorithm.
 * In fact, the algorithms require a minimal property set, but users are free to extend them with their own properties.
 *
 * ### Tracker
 * In general, a Graph may contain loops or merging branches, which will eventually lead to multiple discovery of the same vertices. The trackers task is then
 * to identify these multiple discoveries and decide if the current vertex should be further investigated or skipped. There are three exploration states, a vertex
 * can be in:
 * - ``unknown``: The vertex is not known by the tracker and should be further investigated.
 * - ``discovered``: The tracker already knows about the vertex, but there may be still a better solution, thus it should be further investigated.
 * - ``visited``: The vertex has already been visited and should be skipped.
 *
 * The actual tracker implementation is usually one of the first optimizations users can apply. Per default, a hash map is used, which is a good general
 * purpose solution, but isn't the most efficient for many cases. E.g. a grid graph could utilize a 2d bool array, which will then lead to a constant lookup time.
 *
 * ### Queue
 * A queue stores the discovered nodes and returns them back in any order it desires, thus queue doesn't necessarily mean a FIFO structure. In fact, while the breadth-
 * first-search is indeed built on top of an actual queue, the depth-first-search for example utilizes a stack (LIFO) container. A queue therefore has major influence
 * about the algorithms behaviour and should therefore only exchanged with an equivalent container.
 *
 * ### Traverser
 * The traverser couples everything together and can be queried for the next vertex, which will then either return the next visited node, or a null-object if there were
 * no pending nodes left.
 *
 * A traverser can be decorated with ``IterableTraverser``, which in fact provides ``begin`` and ``end`` members, and can then be used as a input-range with any existing
 * algorithms.
 */

namespace sl::graph::concepts
{
	/**
	 * \defgroup GROUP_GRAPH_CONCEPTS concepts
	 * \ingroup GROUP_GRAPH
	 * \brief Contains general library concepts.
	 *\{
	 */

	/**
	 * \brief Checks, whether the given type satisfies the vertex type requirements.
	 * \tparam T Type to check.
	 */
	template <class T>
	concept vertex = sl::concepts::unqualified<T>
					&& std::equality_comparable<T>
					&& std::copyable<T>;

	/**
	 * \brief Checks, whether the given type satisfies the weight type requirements.
	 * \tparam T Type to check.
	 */
	template <class T>
	concept weight = sl::concepts::unqualified<T>
					&& std::copyable<T>
					&& sl::concepts::plus<T>
					&& sl::concepts::minus<T>
					&& sl::concepts::plus_assign<T>
					&& sl::concepts::minus_assign<T>;

	/**
	 * \brief Checks, whether the given type satisfies the rank type requirements.
	 * \tparam T Type to check.
	 */
	template <class T>
	concept rank = sl::concepts::unqualified<T>
					&& std::regular<T>
					&& std::totally_ordered<T>;

	/**
	 * \brief Checks, whether the given type contains a ``vertex_type`` member alias.
	 * \tparam T Type to check.
	 */
	template <class T>
	concept readable_vertex_type = requires { typename T::vertex_type; }
									&& vertex<typename T::vertex_type>;

	/**
	 * \brief Checks, whether the given type contains a ``weight_type`` member alias.
	 * \tparam T Type to check.
	 */
	template <class T>
	concept readable_weight_type = requires { typename T::weight_type; }
									&& weight<typename T::weight_type>;

	/**
	 * \brief Checks, whether the given type contains a ``rank_type`` member alias.
	 * \tparam T Type to check.
	 */
	template <class T>
	concept readable_rank_type = requires { typename T::rank_type; }
								&& rank<typename T::rank_type>;

	/**
	 * \}
	 */
}

#endif
