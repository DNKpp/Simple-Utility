<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simple-Utility: nullables</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Simple-Utility<span id="projectnumber">&#160;v2.3.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d1/d3d/group___g_r_o_u_p___n_u_l_l_a_b_l_e_s.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#concepts">Concepts</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">nullables</div></div>
</div><!--header-->
<div class="contents">

<p>This library offers some simple algorithms for convenient working with <a class="el" href="../../de/dd6/conceptsl_1_1nullables_1_1nullable.html">nullable</a> types.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for nullables:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d1/d3d/group___g_r_o_u_p___n_u_l_l_a_b_l_e_s.svg" width="282" height="195"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:df/dc9/group___g_r_o_u_p___n_u_l_l_a_b_l_e_s___a_d_a_p_t_e_r"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dc9/group___g_r_o_u_p___n_u_l_l_a_b_l_e_s___a_d_a_p_t_e_r.html">adapter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d6/d1d/group___g_r_o_u_p___n_u_l_l_a_b_l_e_s___a_l_g_o_r_i_t_h_m_s"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d1d/group___g_r_o_u_p___n_u_l_l_a_b_l_e_s___a_l_g_o_r_i_t_h_m_s.html">algorithms</a></td></tr>
<tr class="memdesc:d6/d1d/group___g_r_o_u_p___n_u_l_l_a_b_l_e_s___a_l_g_o_r_i_t_h_m_s"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains nullable algorithm related symbols. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d5/d8f/group___g_r_o_u_p___n_u_l_l_a_b_l_e_s___c_u_s_t_o_m_i_z_a_t_i_o_n___p_o_i_n_t_s"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d8f/group___g_r_o_u_p___n_u_l_l_a_b_l_e_s___c_u_s_t_o_m_i_z_a_t_i_o_n___p_o_i_n_t_s.html">customization points</a></td></tr>
<tr class="memdesc:d5/d8f/group___g_r_o_u_p___n_u_l_l_a_b_l_e_s___c_u_s_t_o_m_i_z_a_t_i_o_n___p_o_i_n_t_s"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains several customization points, which users may hook for their custom types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dd/dc8/group___g_r_o_u_p___n_u_l_l_a_b_l_e_s___t_r_a_i_t_s"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dc8/group___g_r_o_u_p___n_u_l_l_a_b_l_e_s___t_r_a_i_t_s.html">traits</a></td></tr>
<tr class="memdesc:dd/dc8/group___g_r_o_u_p___n_u_l_l_a_b_l_e_s___t_r_a_i_t_s"><td class="mdescLeft">&#160;</td><td class="mdescRight">These traits are used by the <a class="el" href="../../d6/d1d/group___g_r_o_u_p___n_u_l_l_a_b_l_e_s___a_l_g_o_r_i_t_h_m_s.html">algorithms</a> and my be specialized by users for their custom types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d54/conceptsl_1_1nullables_1_1input__nullable.html">sl::nullables::input_nullable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a type is an <a class="el" href="../../d1/d54/conceptsl_1_1nullables_1_1input__nullable.html">input_nullable</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dd6/conceptsl_1_1nullables_1_1nullable.html">sl::nullables::nullable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a type is <a class="el" href="../../de/dd6/conceptsl_1_1nullables_1_1nullable.html">nullable</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaa4b9594cafb202848ac21f9b59a63fa0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d3d/group___g_r_o_u_p___n_u_l_l_a_b_l_e_s.html#gaa4b9594cafb202848ac21f9b59a63fa0">sl::nullables::traits&lt; T &gt;::value_type</a> = std::remove_pointer_t&lt; T &gt;</td></tr>
<tr class="separator:gaa4b9594cafb202848ac21f9b59a63fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga3ab185587ab100161d29d1079bf00e5d"><td class="memItemLeft" align="right" valign="top">static constexpr std::nullptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d3d/group___g_r_o_u_p___n_u_l_l_a_b_l_e_s.html#ga3ab185587ab100161d29d1079bf00e5d">sl::nullables::traits&lt; T &gt;::null</a> {nullptr}</td></tr>
<tr class="separator:ga3ab185587ab100161d29d1079bf00e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This library offers some simple algorithms for convenient working with <a class="el" href="../../de/dd6/conceptsl_1_1nullables_1_1nullable.html">nullable</a> types. </p>
<h2><a class="anchor" id="autotoc_md2"></a>
General</h2>
<p>The algorithms may be chained in arbitrary combination and deepness, as long as it makes sense to the compiler. Such a chain may involve multiple different <a class="el" href="../../de/dd6/conceptsl_1_1nullables_1_1nullable.html">nullable</a> types. Of this library explicitly supported types are:</p><ul>
<li><a class="el" href="../../da/da9/classsl_1_1unique__handle.html">sl::unique_handle</a> ("Simple-Utility/unique_handle.hpp" header must be included)</li>
<li><a href="https://en.cppreference.com/w/cpp/utility/optional">std::optional</a> ("Simple-Utility/nullables/std_optional.hpp" header must be included)</li>
<li><a href="https://en.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr</a> ("Simple-Utility/nullables/std_pointers.hpp" header must be included)</li>
<li><a href="https://en.cppreference.com/w/cpp/memory/shared_ptr">std::shared_ptr</a> ("Simple-Utility/nullables/std_pointers.hpp" header must be included)</li>
<li>and <code>raw pointers</code></li>
</ul>
<p>The general idea is making the handling with types e.g. <code>std::optional</code> less verbose and more enjoyable. The syntax is inspired by the <code>std::ranges</code> library and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0798r8.html">this proposal</a>. If you would like to learn more about an algorithm, just visit the specific sub-page:</p><ul>
<li><a class="el" href="../../d6/d1d/group___g_r_o_u_p___n_u_l_l_a_b_l_e_s___a_l_g_o_r_i_t_h_m_s.html#gaae1a179ae42bf4201989653557976479">or_else</a></li>
<li><a class="el" href="../../d6/d1d/group___g_r_o_u_p___n_u_l_l_a_b_l_e_s___a_l_g_o_r_i_t_h_m_s.html#ga405026999e94e6daeab19a0327a3779e">and_then</a></li>
<li><a class="el" href="../../d6/d1d/group___g_r_o_u_p___n_u_l_l_a_b_l_e_s___a_l_g_o_r_i_t_h_m_s.html#ga74afba8ed89e9dc1171b5868cf525027">value_or</a></li>
<li><a class="el" href="../../d6/d1d/group___g_r_o_u_p___n_u_l_l_a_b_l_e_s___a_l_g_o_r_i_t_h_m_s.html#ga51392e2d61b33585d728efbbf32b4f26">fwd_value</a></li>
</ul>
<h3><a class="anchor" id="autotoc_md3"></a>
Quick algorithm example</h3>
<p>This example demonstrates that <a class="el" href="../../d6/d1d/group___g_r_o_u_p___n_u_l_l_a_b_l_e_s___a_l_g_o_r_i_t_h_m_s.html#ga405026999e94e6daeab19a0327a3779e">and_then</a> and <a class="el" href="../../d6/d1d/group___g_r_o_u_p___n_u_l_l_a_b_l_e_s___a_l_g_o_r_i_t_h_m_s.html#gaae1a179ae42bf4201989653557976479">or_else</a> algorithms can be chained in arbitrarily length. <a class="el" href="../../d6/d1d/group___g_r_o_u_p___n_u_l_l_a_b_l_e_s___a_l_g_o_r_i_t_h_m_s.html#ga74afba8ed89e9dc1171b5868cf525027">value_or</a> and <a class="el" href="../../d6/d1d/group___g_r_o_u_p___n_u_l_l_a_b_l_e_s___a_l_g_o_r_i_t_h_m_s.html#ga51392e2d61b33585d728efbbf32b4f26">fwd_value</a> on the other side act as a terminator (as they usually do not return a <a class="el" href="../../de/dd6/conceptsl_1_1nullables_1_1nullable.html">nullable</a> objects). </p><div class="fragment"><div class="line">    <span class="keyword">const</span> std::string result = std::optional{42}</div>
<div class="line">                                | <a class="code hl_variable" href="../../d6/d1d/group___g_r_o_u_p___n_u_l_l_a_b_l_e_s___a_l_g_o_r_i_t_h_m_s.html#gaae1a179ae42bf4201989653557976479">or_else</a>([] { <span class="keywordflow">throw</span> std::runtime_error{<span class="stringliteral">&quot;invalid optional.&quot;</span>}; })</div>
<div class="line">                                | <a class="code hl_variable" href="../../d6/d1d/group___g_r_o_u_p___n_u_l_l_a_b_l_e_s___a_l_g_o_r_i_t_h_m_s.html#ga405026999e94e6daeab19a0327a3779e">and_then</a>([](<span class="keyword">const</span> <span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> std::optional{i * i}; })</div>
<div class="line">                                | <a class="code hl_variable" href="../../d6/d1d/group___g_r_o_u_p___n_u_l_l_a_b_l_e_s___a_l_g_o_r_i_t_h_m_s.html#ga405026999e94e6daeab19a0327a3779e">and_then</a>([](<span class="keyword">const</span> <span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> std::optional{std::to_string(i)}; })</div>
<div class="line">                                | <a class="code hl_variable" href="../../d6/d1d/group___g_r_o_u_p___n_u_l_l_a_b_l_e_s___a_l_g_o_r_i_t_h_m_s.html#ga74afba8ed89e9dc1171b5868cf525027">value_or</a>(<span class="stringliteral">&quot;not set&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    REQUIRE(result == <span class="stringliteral">&quot;1764&quot;</span>);</div>
<div class="ttc" id="agroup___g_r_o_u_p___n_u_l_l_a_b_l_e_s___a_l_g_o_r_i_t_h_m_s_html_ga405026999e94e6daeab19a0327a3779e"><div class="ttname"><a href="../../d6/d1d/group___g_r_o_u_p___n_u_l_l_a_b_l_e_s___a_l_g_o_r_i_t_h_m_s.html#ga405026999e94e6daeab19a0327a3779e">sl::nullables::and_then</a></div><div class="ttdeci">constexpr auto and_then</div><div class="ttdoc">Passes the value of the input_nullable to the function if it's not equal to its null-object....</div><div class="ttdef"><b>Definition:</b> and_then.hpp:79</div></div>
<div class="ttc" id="agroup___g_r_o_u_p___n_u_l_l_a_b_l_e_s___a_l_g_o_r_i_t_h_m_s_html_ga74afba8ed89e9dc1171b5868cf525027"><div class="ttname"><a href="../../d6/d1d/group___g_r_o_u_p___n_u_l_l_a_b_l_e_s___a_l_g_o_r_i_t_h_m_s.html#ga74afba8ed89e9dc1171b5868cf525027">sl::nullables::value_or</a></div><div class="ttdeci">constexpr auto value_or</div><div class="ttdoc">Retrieves the value of a input_nullable if it's not equal to its ''null''-object. Returns the alterna...</div><div class="ttdef"><b>Definition:</b> value_or.hpp:73</div></div>
<div class="ttc" id="agroup___g_r_o_u_p___n_u_l_l_a_b_l_e_s___a_l_g_o_r_i_t_h_m_s_html_gaae1a179ae42bf4201989653557976479"><div class="ttname"><a href="../../d6/d1d/group___g_r_o_u_p___n_u_l_l_a_b_l_e_s___a_l_g_o_r_i_t_h_m_s.html#gaae1a179ae42bf4201989653557976479">sl::nullables::or_else</a></div><div class="ttdeci">constexpr auto or_else</div><div class="ttdoc">Returns the nullable if it's not equal to its ''null''-object. Executes the passed function otherwise...</div><div class="ttdef"><b>Definition:</b> or_else.hpp:90</div></div>
</div><!-- fragment --><p>This can be quite useful, but the library can even better than this. All nullable algorithms are designed to work properly with the functional part of this library, thus the above example can be adjusted like this: </p><div class="fragment"><div class="line">    <span class="keyword">namespace </span>fn = <a class="code hl_namespace" href="../../d9/da2/namespacesl_1_1functional.html">sl::functional</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> square = fn::envelop&lt;fn::Transform&gt;([](<span class="keyword">const</span> std::integral <span class="keyword">auto</span> i) { <span class="keywordflow">return</span> i * i; });</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> to_string= fn::envelop&lt;fn::Transform&gt;([](<span class="keyword">const</span> std::integral <span class="keyword">auto</span> i) { <span class="keywordflow">return</span> std::to_string(i); });</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> std::string result = std::optional{42}</div>
<div class="line">                                | <a class="code hl_variable" href="../../d6/d1d/group___g_r_o_u_p___n_u_l_l_a_b_l_e_s___a_l_g_o_r_i_t_h_m_s.html#gaae1a179ae42bf4201989653557976479">or_else</a>([] { <span class="keywordflow">throw</span> std::runtime_error{<span class="stringliteral">&quot;invalid optional.&quot;</span>}; })</div>
<div class="line">                                | <a class="code hl_variable" href="../../d6/d1d/group___g_r_o_u_p___n_u_l_l_a_b_l_e_s___a_l_g_o_r_i_t_h_m_s.html#ga405026999e94e6daeab19a0327a3779e">and_then</a>(</div>
<div class="line">                                    square</div>
<div class="line">                                    | to_string</div>
<div class="line">                                    | fn::util::as&lt;std::optional&lt;std::string&gt;&gt;)</div>
<div class="line">                                | <a class="code hl_variable" href="../../d6/d1d/group___g_r_o_u_p___n_u_l_l_a_b_l_e_s___a_l_g_o_r_i_t_h_m_s.html#ga74afba8ed89e9dc1171b5868cf525027">value_or</a>(<span class="stringliteral">&quot;not set&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    REQUIRE(result == <span class="stringliteral">&quot;1764&quot;</span>);</div>
<div class="ttc" id="anamespacesl_1_1functional_html"><div class="ttname"><a href="../../d9/da2/namespacesl_1_1functional.html">sl::functional</a></div><div class="ttdef"><b>Definition:</b> Arithmetic.hpp:13</div></div>
</div><!-- fragment --><p>At last I would like to quickly present a naive comparison between the usual stl style and the style this library offers. In this example I utilize a adapter, which already supports iterator adapting out of the box. </p><div class="fragment"><div class="line">    <span class="keyword">namespace </span>fn = <a class="code hl_namespace" href="../../d9/da2/namespacesl_1_1functional.html">sl::functional</a>;</div>
<div class="line">    <span class="keyword">namespace </span>na = <a class="code hl_namespace" href="../../d0/de0/namespacesl_1_1nullables.html">sl::nullables</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> std::map&lt;int, const char*&gt; global_storage{</div>
<div class="line">        {42, <span class="stringliteral">&quot;Hello, World!&quot;</span>},</div>
<div class="line">        {1337, <span class="stringliteral">&quot;Insert Coin&quot;</span>}</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> get_from_storage_stl = [&amp;](<span class="keyword">const</span> <span class="keywordtype">int</span> key) -&gt; std::optional&lt;std::string_view&gt;</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span> itr = global_storage.find(key); itr != std::end(global_storage))</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">return</span> itr-&gt;second;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> std::nullopt;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> get_from_storage_adapted = [&amp;](<span class="keyword">const</span> <span class="keywordtype">int</span> key)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> na::adapter{global_storage.end(), global_storage.find(key)}</div>
<div class="line">                | na::and_then(fn::tuple::get_at&lt;1&gt; | fn::util::as&lt;std::optional&lt;std::string_view&gt;&gt;);</div>
<div class="line">    };</div>
<div class="ttc" id="anamespacesl_1_1nullables_html"><div class="ttname"><a href="../../d0/de0/namespacesl_1_1nullables.html">sl::nullables</a></div><div class="ttdef"><b>Definition:</b> adapter.hpp:19</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md4"></a>
Using custom types</h2>
<p>Well, that depends which interface your type offers. If it's already dereferencable via <code>operator *</code> and it has an explicit <code>null</code>-object, which it can equality compared to, than you are in a good position.</p>
<h3><a class="anchor" id="autotoc_md5"></a>
There exists a dedicated type or constexpr null object</h3>
<p>Just specialize <a class="el" href="../../d7/db1/structsl_1_1nullables_1_1traits.html">nullable traits</a>. If your type then doesn't offer a <code>operator *</code> access or it doesn't follow the semantics, you can hook the <code>unwrap</code> customization point and simply create an overload in the types namespace.</p>
<h3><a class="anchor" id="autotoc_md6"></a>
No dedicated type or constexpr null object exists</h3>
<p>If your type doesn't have a dedicated null object or it is simply not constexpr constructible, you can wrap your type and a null object into <a class="el" href="../../d1/dc6/classsl_1_1nullables_1_1adapter.html">adapter</a> object. Depending how your type behaves with the null object, this adapter will be either a <code>input_nullable</code> or even a <code>nullable</code>.</p>
<p>If your type doesn't offer a <code>operator *</code> access or it doesn't follow the semantics, you can hook the <code>unwrap_adapted</code> customization point and simply create an overload in the types namespace. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaa4b9594cafb202848ac21f9b59a63fa0" name="gaa4b9594cafb202848ac21f9b59a63fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4b9594cafb202848ac21f9b59a63fa0">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d7/db1/structsl_1_1nullables_1_1traits.html">sl::nullables::traits</a>&lt; T &gt;::value_type =  std::remove_pointer_t&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga3ab185587ab100161d29d1079bf00e5d" name="ga3ab185587ab100161d29d1079bf00e5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ab185587ab100161d29d1079bf00e5d">&#9670;&#160;</a></span>null</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::nullptr_t <a class="el" href="../../d7/db1/structsl_1_1nullables_1_1traits.html">sl::nullables::traits</a>&lt; T &gt;::null {nullptr}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
